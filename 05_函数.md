# 函数定义与使用

## 1. 函数基础

### 函数定义语法
```bash
# 方法1：function关键字
function function_name() {
    # 函数体
}

# 方法2：直接定义（推荐）
function_name() {
    # 函数体
}

# 简单示例
greet() {
    echo "Hello, World!"
}

# 调用函数
greet
```

### 函数参数
```bash
#!/bin/bash

# 带参数的函数
greet_user() {
    local name="$1"
    local age="$2"
    
    if [[ -z "$name" ]]; then
        echo "错误: 请提供姓名"
        return 1
    fi
    
    echo "你好, $name!"
    if [[ -n "$age" ]]; then
        echo "你今年 $age 岁了。"
    fi
}

# 调用函数
greet_user "张三" 25
greet_user "李四"
```

### 函数返回值
```bash
#!/bin/bash

# 返回数值状态码
is_even() {
    local number="$1"
    if [[ $((number % 2)) -eq 0 ]]; then
        return 0  # 成功/真
    else
        return 1  # 失败/假
    fi
}

# 使用返回值
if is_even 10; then
    echo "10是偶数"
fi

# 返回字符串（通过echo）
get_timestamp() {
    echo "$(date '+%Y-%m-%d %H:%M:%S')"
}

# 捕获函数输出
current_time=$(get_timestamp)
echo "当前时间: $current_time"
```

## 2. 局部变量和作用域

### 局部变量
```bash
#!/bin/bash

global_var="我是全局变量"

test_scope() {
    local local_var="我是局部变量"
    global_var="函数内修改全局变量"
    
    echo "函数内 - 局部变量: $local_var"
    echo "函数内 - 全局变量: $global_var"
}

echo "调用前 - 全局变量: $global_var"
test_scope
echo "调用后 - 全局变量: $global_var"
# echo "调用后 - 局部变量: $local_var"  # 这会报错
```

### 变量传递
```bash
#!/bin/bash

# 通过nameref传递数组
modify_array() {
    local -n arr_ref=$1  # nameref引用
    local new_item="$2"
    
    arr_ref+=("$new_item")
}

# 使用示例
my_array=("apple" "banana")
echo "修改前: ${my_array[@]}"

modify_array my_array "orange"
echo "修改后: ${my_array[@]}"
```

## 3. 高级函数技巧

### 递归函数
```bash
#!/bin/bash

# 计算阶乘
factorial() {
    local n="$1"
    
    if [[ $n -le 1 ]]; then
        echo 1
    else
        local prev=$(factorial $((n-1)))
        echo $((n * prev)) #比如计算factorial(4) = 4 * factorial(3) = 4 * (3 * factorial(2)) = 4 * (3 * (2 * factorial(1))) = 4 * (3 * (2 * 1)) = 4 * (3 * 2) = 4 * 6 = 24
    fi
}

# 斐波那契数列
fibonacci() {
    local n="$1"
    
    if [[ $n -le 1 ]]; then
        echo $n
    else
        local a=$(fibonacci $((n-1)))
        local b=$(fibonacci $((n-2)))
        echo $((a + b))
    fi
}

# 使用示例
echo "5的阶乘: $(factorial 5)"
echo "第10个斐波那契数: $(fibonacci 10)"
```

### 函数重载模拟
```bash
#!/bin/bash

# 根据参数数量执行不同逻辑
process_data() {
    case $# in
        1)
            # 单参数处理
            echo "处理单个数据: $1"
            ;;
        2)
            # 双参数处理
            echo "处理数据对: $1 和 $2"
            ;;
        *)
            # 多参数处理
            echo "处理多个数据: $*"
            ;;
    esac
}

process_data "A"
process_data "A" "B"
process_data "A" "B" "C" "D"
```

### 函数作为参数
```bash
#!/bin/bash

# 高阶函数示例
apply_operation() {
    local operation="$1"
    local value="$2"
    
    $operation "$value"
}

# 操作函数
double() {
    echo $(($1 * 2))
}

square() {
    echo $(($1 * $1))
}

# 使用示例
result1=$(apply_operation double 5)
result2=$(apply_operation square 5)

echo "5的两倍: $result1"
echo "5的平方: $result2"
```

## 4. 错误处理和调试

### 函数错误处理
```bash
#!/bin/bash

# 带错误处理的函数
safe_divide() {
    local dividend="$1"
    local divisor="$2"
    
    # 参数验证
    if [[ $# -ne 2 ]]; then
        echo "错误: 需要两个参数" >&2
        return 1
    fi
    
    # 数值验证
    if ! [[ "$dividend" =~ ^-?[0-9]+$ ]] || ! [[ "$divisor" =~ ^-?[0-9]+$ ]]; then
        echo "错误: 参数必须是整数" >&2
        return 2
    fi
    
    # 除零检查
    if [[ $divisor -eq 0 ]]; then
        echo "错误: 除数不能为零" >&2
        return 3
    fi
    
    # 执行除法
    echo $((dividend / divisor))
    return 0
}

# 使用示例
if result=$(safe_divide 10 2); then
    echo "结果: $result"
else
    echo "计算失败，错误码: $?"
fi
```

### 函数调试
```bash
#!/bin/bash

# 调试函数
debug_function() {
    local func_name="${FUNCNAME[1]}" # 获取当前函数的名称
    local line_no="${BASH_LINENO[0]}" # 获取当前行号
    
    
echo -e "\033[32m当前[DEBUG] 函数名为: $func_name, 调用该函数的行号为: $line_no, 函数入参为: $*\033[0m" >&2
}

# 带调试的函数
calculate_sum() {
    debug_function "$@"
    
    local sum=0
    for num in "$@"; do
        sum=$((sum + num))
    done
    
    echo $sum
}

# 启用调试
set -x
result=$(calculate_sum 1 2 3 4 5)
set +x

echo "总和: $result"
```

## 5. 实用函数库

### 字符串处理函数
```bash
#!/bin/bash

# 字符串长度
str_length() {
    echo ${#1}
}

# 字符串转大写
str_upper() {
    echo "${1^^}"
}

# 字符串转小写
str_lower() {
    echo "${1,,}"
}

# 字符串首字母大写
str_capitalize() {
    local str="$1"
    echo "${str^}"
}

str_trim() {
    local str="$1"
    # 去除前导空格
    str="${str#"${str%%[![:space:]]*}"}" 
    # 这段代码用于去除字符串开头的空白字符
    # ${str%%[![:space:]]*} - 从字符串末尾开始，删除最长匹配的非空白字符序列，只保留开头的空白字符
    # ${str#"${str%%[![:space:]]*}"} - 从字符串开头删除上面匹配到的空白字符部分
    # 去除尾随空格
    str="${str%"${str##*[![:space:]]}"}" 
    #这段代码用于去除字符串结尾的空白字符
    # ${str##*[![:space:]]} - 从字符串开头开始，删除最长匹配的非空字符序列，只保留结尾的空白字符
    # ${str%"${str##*[!][:space:]]}"} - 从字符串末尾开始删除上面匹配到的空白字符部分
    echo "$str"
}

# 字符串分割
str_split() {
    local string="$1"
    local delimiter="$2"
    local -a result=()
    
    IFS="$delimiter" read -ra result <<< "$string"
    printf '%s\n' "${result[@]}"
}

# 使用示例
text="  Hello World  "
echo "原文: '$text'"
echo "长度: $(str_length "$text")"
echo "大写: $(str_upper "$text")"
echo "小写: $(str_lower "$text")"
echo "去空格: '$(str_trim "$text")'"

echo "分割示例:"
str_split "apple,banana,orange" ","
```

### 文件操作函数
```bash
#!/bin/bash

# 检查文件是否存在
file_exists() {
    [[ -f "$1" ]]
}

# 检查目录是否存在
dir_exists() {
    [[ -d "$1" ]]
}

# 创建目录（如果不存在）
ensure_dir() {
    local dir="$1"
    if ! dir_exists "$dir"; then
        mkdir -p "$dir"
        echo "创建目录: $dir"
    fi
}

# 安全删除文件
safe_remove() {
    local file="$1"
    if file_exists "$file"; then
        rm "$file"
        echo "删除文件: $file"
    else
        echo "文件不存在: $file"
    fi
}

# 备份文件
backup_file() {
    local file="$1"
    local backup_dir="${2:-./backup}"
    
    if ! file_exists "$file"; then
        echo "错误: 文件不存在 - $file" >&2
        return 1
    fi
    
    ensure_dir "$backup_dir"
    local backup_name="$(basename "$file").$(date +%Y%m%d_%H%M%S).bak"
    local backup_path="$backup_dir/$backup_name"
    
    cp "$file" "$backup_path"
    echo "备份完成: $file -> $backup_path"
}

# 获取文件大小
get_file_size() {
    local file="$1"
    if file_exists "$file"; then
        stat -f%z "$file" 2>/dev/null || stat -c%s "$file"
    else
        echo 0
    fi
}
```

### 日期时间函数
```bash
#!/bin/bash

# 获取当前时间戳
get_timestamp() {
    date +%s
}

# 格式化时间戳
format_timestamp() {
    local timestamp="$1"
    local format="${2:-%Y-%m-%d %H:%M:%S}"
    date -d "@$timestamp" +"$format" 2>/dev/null || date -r "$timestamp" +"$format"
}

# 计算时间差（秒）
time_diff() {
    local start_time="$1"
    local end_time="$2"
    echo $((end_time - start_time))
}

# 人性化时间差
human_time_diff() {
    local seconds="$1"
    local days=$((seconds / 86400))
    local hours=$(((seconds % 86400) / 3600))
    local minutes=$(((seconds % 3600) / 60))
    local secs=$((seconds % 60))
    
    if [[ $days -gt 0 ]]; then
        echo "${days}天 ${hours}小时 ${minutes}分钟 ${secs}秒"
    elif [[ $hours -gt 0 ]]; then
        echo "${hours}小时 ${minutes}分钟 ${secs}秒"
    elif [[ $minutes -gt 0 ]]; then
        echo "${minutes}分钟 ${secs}秒"
    else
        echo "${secs}秒"
    fi
}

# 使用示例
start=$(get_timestamp)
sleep 2
end=$(get_timestamp)

diff=$(time_diff $start $end)
echo "执行时间: $(human_time_diff $diff)"
```

## 6. 函数库管理

### 创建函数库文件
```bash
# utils.sh - 通用工具函数库
#!/bin/bash

# 日志函数
log() {
    local level="$1"
    shift
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [$level] $*"
}

log_info() {
    log "INFO" "$@"
}

log_warn() {
    log "WARN" "$@"
}

log_error() {
    log "ERROR" "$@" >&2
}

# 配置读取函数
read_config() {
    local config_file="$1"
    local key="$2"
    
    if [[ -f "$config_file" ]]; then
        grep "^$key=" "$config_file" | cut -d'=' -f2- | tr -d '"'
    fi
}

# 进程检查函数
is_process_running() {
    local process_name="$1"
    pgrep -f "$process_name" > /dev/null
}

# 网络检查函数
check_port() {
    local host="$1"
    local port="$2"
    local timeout="${3:-5}"
    
    timeout "$timeout" bash -c "echo >/dev/tcp/$host/$port" 2>/dev/null
}

# 重试函数
retry() {
    local max_attempts="$1"
    local delay="$2"
    shift 2
    
    local attempt=1
    while [[ $attempt -le $max_attempts ]]; do
        if "$@"; then
            return 0
        fi
        
        log_warn "尝试 $attempt/$max_attempts 失败，${delay}秒后重试..."
        sleep "$delay"
        ((attempt++))
    done
    
    log_error "所有尝试都失败了"
    return 1
}
```

### 使用函数库
```bash
#!/bin/bash
# main_script.sh - 主脚本

# 导入函数库
source "$(dirname "$0")/utils.sh"

main() {
    log_info "脚本开始执行"
    
    # 使用重试函数
    if retry 3 2 check_port "google.com" 80; then
        log_info "网络连接正常"
    else
        log_error "网络连接失败"
        exit 1
    fi
    
    # 检查进程
    if is_process_running "nginx"; then
        log_info "Nginx正在运行"
    else
        log_warn "Nginx未运行"
    fi
    
    log_info "脚本执行完成"
}

main "$@"
```

## 实践练习

### 练习1：数学计算库
```bash
#!/bin/bash
# math_lib.sh - 数学计算函数库

# 加法
add() {
    echo $(($1 + $2))
}

# 减法
subtract() {
    echo $(($1 - $2))
}

# 乘法
multiply() {
    echo $(($1 * $2))
}

# 除法（支持小数）
divide() {
    local dividend="$1"
    local divisor="$2"
    
    if [[ $divisor -eq 0 ]]; then
        echo "错误: 除数不能为零" >&2
        return 1
    fi
    
    echo "scale=2; $dividend / $divisor" | bc
}

# 求幂
power() {
    local base="$1"
    local exponent="$2"
    echo "$base ^ $exponent" | bc
}

# 求平方根
sqrt() {
    local number="$1"
    echo "scale=2; sqrt($number)" | bc
}

# 求最大值
max() {
    local max_val="$1"
    shift
    
    for num in "$@"; do
        if [[ $num -gt $max_val ]]; then
            max_val="$num"
        fi
    done
    
    echo "$max_val"
}

# 求最小值
min() {
    local min_val="$1"
    shift
    
    for num in "$@"; do
        if [[ $num -lt $min_val ]]; then
            min_val="$num"
        fi
    done
    
    echo "$min_val"
}

# 求平均值
average() {
    local sum=0
    local count=0
    
    for num in "$@"; do
        sum=$((sum + num))
        ((count++))
    done
    
    if [[ $count -eq 0 ]]; then
        echo 0
    else
        echo "scale=2; $sum / $count" | bc
    fi
}

# 测试函数
test_math_lib() {
    echo "=== 数学库测试 ==="
    echo "10 + 5 = $(add 10 5)"
    echo "10 - 5 = $(subtract 10 5)"
    echo "10 * 5 = $(multiply 10 5)"
    echo "10 / 3 = $(divide 10 3)"
    echo "2 ^ 8 = $(power 2 8)"
    echo "sqrt(16) = $(sqrt 16)"
    echo "max(1,5,3,9,2) = $(max 1 5 3 9 2)"
    echo "min(1,5,3,9,2) = $(min 1 5 3 9 2)"
    echo "avg(1,5,3,9,2) = $(average 1 5 3 9 2)"
}

# 如果直接运行此脚本，执行测试
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    test_math_lib
fi
```

### 练习2：系统信息收集器
```bash
#!/bin/bash
# system_info.sh - 系统信息收集器

# 获取系统基本信息
get_system_info() {
    echo "=== 系统信息 ==="
    echo "主机名: $(hostname)"
    echo "操作系统: $(uname -s)"
    echo "内核版本: $(uname -r)"
    echo "架构: $(uname -m)"
    echo "启动时间: $(uptime -s 2>/dev/null || uptime)"
}

# 获取CPU信息
get_cpu_info() {
    echo "=== CPU信息 ==="
    if [[ -f /proc/cpuinfo ]]; then
        local cpu_model=$(grep "model name" /proc/cpuinfo | head -1 | cut -d: -f2 | xargs)
        local cpu_cores=$(grep -c "^processor" /proc/cpuinfo)
        echo "CPU型号: $cpu_model"
        echo "CPU核心数: $cpu_cores"
    else
        echo "CPU信息: $(sysctl -n machdep.cpu.brand_string 2>/dev/null || echo "无法获取")"
    fi
    
    local cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | sed 's/%us,//' 2>/dev/null)
    echo "CPU使用率: ${cpu_usage:-无法获取}"
}

# 获取内存信息
get_memory_info() {
    echo "=== 内存信息 ==="
    if command -v free >/dev/null; then
        free -h
    else
        echo "内存信息: $(vm_stat 2>/dev/null | head -5 || echo "无法获取")"
    fi
}

# 获取磁盘信息
get_disk_info() {
    echo "=== 磁盘信息 ==="
    df -h | grep -E "^/dev|^Filesystem"
}

# 获取网络信息
get_network_info() {
    echo "=== 网络信息 ==="
    
    # IP地址
    local ip_addr=$(ip route get 8.8.8.8 2>/dev/null | awk '{print $7; exit}' || \
                   ifconfig | grep "inet " | grep -v "127.0.0.1" | awk '{print $2}' | head -1)
    echo "IP地址: ${ip_addr:-无法获取}"
    
    # 网络接口
    if command -v ip >/dev/null; then
        echo "网络接口:"
        ip link show | grep -E "^[0-9]+" | awk '{print "  " $2}' | sed 's/://'
    elif command -v ifconfig >/dev/null; then
        echo "网络接口:"
        ifconfig | grep -E "^[a-z]" | awk '{print "  " $1}' | sed 's/://'
    fi
}

# 获取进程信息
get_process_info() {
    echo "=== 进程信息 ==="
    echo "总进程数: $(ps aux | wc -l)"
    echo "运行中进程数: $(ps aux | awk '$8 ~ /^R/ {count++} END {print count+0}')"
    
    echo "CPU占用最高的5个进程:"
    ps aux --no-headers | sort -k3 -nr | head -5 | awk '{printf "  %s: %.1f%%\n", $11, $3}'
}

# 获取服务状态
get_service_status() {
    echo "=== 服务状态 ==="
    local services=("ssh" "nginx" "apache2" "mysql" "postgresql")
    
    for service in "${services[@]}"; do
        if command -v systemctl >/dev/null; then
            local status=$(systemctl is-active "$service" 2>/dev/null)
            echo "  $service: ${status:-未安装}"
        elif command -v service >/dev/null; then
            if service "$service" status >/dev/null 2>&1; then
                echo "  $service: 运行中"
            else
                echo "  $service: 已停止或未安装"
            fi
        fi
    done
}

# 生成完整报告
generate_report() {
    local output_file="${1:-system_report.txt}"
    
    {
        echo "系统信息报告"
        echo "生成时间: $(date)"
        echo "========================================"
        echo
        
        get_system_info
        echo
        get_cpu_info
        echo
        get_memory_info
        echo
        get_disk_info
        echo
        get_network_info
        echo
        get_process_info
        echo
        get_service_status
        
    } | tee "$output_file"
    
    echo
    echo "报告已保存到: $output_file"
}

# 主函数
main() {
    case "${1:-all}" in
        system)
            get_system_info
            ;;
        cpu)
            get_cpu_info
            ;;
        memory)
            get_memory_info
            ;;
        disk)
            get_disk_info
            ;;
        network)
            get_network_info
            ;;
        process)
            get_process_info
            ;;
        service)
            get_service_status
            ;;
        report)
            generate_report "$2"
            ;;
        all)
            get_system_info
            echo
            get_cpu_info
            echo
            get_memory_info
            echo
            get_disk_info
            echo
            get_network_info
            ;;
        *)
            echo "用法: $0 [system|cpu|memory|disk|network|process|service|report|all] [输出文件]"
            exit 1
            ;;
    esac
}

main "$@"
```

## 最佳实践

1. **函数命名**：使用动词开头的描述性名称
2. **参数验证**：总是验证函数参数的有效性
3. **局部变量**：在函数内使用 `local` 声明变量
4. **错误处理**：使用适当的返回码和错误信息
5. **文档化**：为复杂函数添加注释说明
6. **单一职责**：每个函数只做一件事
7. **可重用性**：设计通用的、可重用的函数