# 文件操作详解

## 1. 基本文件操作

### 文件创建和删除
```bash
#!/bin/bash

# 创建文件
touch file.txt
echo "Hello World" > file.txt
cat > file.txt << EOF
多行内容
第二行
第三行
EOF

# 创建目录
mkdir new_directory
mkdir -p path/to/nested/directory  # 递归创建

# 删除文件
rm file.txt
rm -f file.txt  # 强制删除，不提示
rm -i file.txt  # 交互式删除，需要确认

# 删除目录
rmdir empty_directory  # 只能删除空目录
rm -r directory        # 递归删除目录及其内容
rm -rf directory       # 强制递归删除
```

### 文件复制和移动
```bash
#!/bin/bash

# 复制文件
cp source.txt destination.txt
cp source.txt /path/to/destination/
cp -r source_directory destination_directory  # 递归复制目录

# 保留属性复制
cp -p source.txt destination.txt  # 保留时间戳和权限
cp -a source_directory destination_directory  # 归档模式，保留所有属性

# 移动/重命名
mv old_name.txt new_name.txt
mv file.txt /path/to/destination/
mv directory /path/to/new/location/
```

### 文件权限和属性
```bash
#!/bin/bash

# 修改权限
chmod 755 script.sh        # 数字模式
chmod u+x script.sh        # 符号模式：用户添加执行权限
chmod g-w file.txt         # 组去除写权限
chmod o=r file.txt         # 其他用户只读权限
chmod a+r file.txt         # 所有用户添加读权限

# 修改所有者
chown user:group file.txt
chown user file.txt
chgrp group file.txt

# 查看文件属性
ls -l file.txt
stat file.txt
file file.txt  # 查看文件类型
```

## 2. 文件内容操作

### 文件读取
```bash
#!/bin/bash

# 读取整个文件
content=$(cat file.txt)
echo "$content"

# 逐行读取
while IFS= read -r line; do
    echo "处理行: $line"
done < file.txt

# 读取指定行数
head -n 10 file.txt    # 前10行
tail -n 10 file.txt    # 后10行
tail -f file.txt       # 实时监控文件变化

# 读取指定范围
sed -n '5,10p' file.txt  # 第5到10行
awk 'NR>=5 && NR<=10' file.txt  # 第5到10行
```

### 文件写入
```bash
#!/bin/bash

# 覆盖写入
echo "新内容" > file.txt
cat > file.txt << EOF
多行内容
第二行
EOF

# 追加写入
echo "追加内容" >> file.txt
cat >> file.txt << EOF
追加的多行内容
第二行
EOF

# 安全写入（原子操作）
safe_write() {
    local file="$1"
    local content="$2"
    local temp_file="${file}.tmp.$$"
    
    echo "$content" > "$temp_file" && mv "$temp_file" "$file"
}

safe_write "important.txt" "重要内容"
```

### 文件搜索和替换
```bash
#!/bin/bash

# 搜索文件内容
grep "pattern" file.txt
grep -n "pattern" file.txt     # 显示行号
grep -i "pattern" file.txt     # 忽略大小写
grep -r "pattern" directory/   # 递归搜索目录
grep -v "pattern" file.txt     # 反向匹配（不包含pattern的行）

# 正则表达式搜索
grep -E "^[0-9]+$" file.txt    # 扩展正则表达式
grep -P "\d{3}-\d{3}-\d{4}" file.txt  # Perl正则表达式

# 替换文件内容
sed 's/old/new/' file.txt              # 替换每行第一个匹配
sed 's/old/new/g' file.txt             # 替换所有匹配
sed 's/old/new/gi' file.txt            # 忽略大小写替换所有匹配
sed -i 's/old/new/g' file.txt          # 直接修改文件

# 复杂替换
sed -i.bak 's/old/new/g' file.txt      # 替换前备份
sed -i '/pattern/d' file.txt           # 删除包含pattern的行
sed -i '5d' file.txt                   # 删除第5行
sed -i '5,10d' file.txt                # 删除第5到10行
```

## 3. 文件查找

### find命令详解
```bash
#!/bin/bash

# 基本查找
find /path -name "*.txt"           # 按名称查找
find /path -iname "*.TXT"          # 忽略大小写查找
find /path -type f                 # 查找文件
find /path -type d                 # 查找目录
find /path -type l                 # 查找符号链接

# 按大小查找
find /path -size +100M             # 大于100MB的文件
find /path -size -1k               # 小于1KB的文件
find /path -size 50c               # 正好50字节的文件

# 按时间查找
find /path -mtime -7               # 7天内修改的文件
find /path -mtime +30              # 30天前修改的文件
find /path -atime -1               # 1天内访问的文件
find /path -ctime +7               # 7天前状态改变的文件

# 按权限查找
find /path -perm 755               # 权限为755的文件
find /path -perm -644              # 至少有644权限的文件
find /path -perm /u+w              # 用户有写权限的文件

# 组合条件
find /path -name "*.log" -size +10M -mtime -7  # 7天内的大于10MB的日志文件
find /path \( -name "*.tmp" -o -name "*.bak" \) -delete  # 删除临时文件和备份文件
```

### 高级查找技巧
```bash
#!/bin/bash

# 查找并执行操作
find /path -name "*.txt" -exec cat {} \;           # 显示所有txt文件内容
find /path -name "*.log" -exec gzip {} \;          # 压缩所有日志文件
find /path -name "*.tmp" -exec rm {} \;            # 删除所有临时文件

# 使用xargs提高效率
find /path -name "*.txt" -print0 | xargs -0 grep "pattern"
find /path -name "*.log" -print0 | xargs -0 -I {} cp {} /backup/

# 查找重复文件
find_duplicates() {
    local directory="$1"
    find "$directory" -type f -exec md5sum {} \; | sort | uniq -d -w32
}

# 查找空文件和空目录
find /path -type f -empty          # 空文件
find /path -type d -empty          # 空目录

# 查找最大的文件
find /path -type f -exec ls -la {} \; | sort -k5 -nr | head -10
```

## 4. 文件压缩和归档

### tar归档
```bash
#!/bin/bash

# 创建归档
tar -cf archive.tar file1 file2 directory/     # 创建tar归档
tar -czf archive.tar.gz file1 file2 directory/ # 创建gzip压缩归档
tar -cjf archive.tar.bz2 file1 file2 directory/ # 创建bzip2压缩归档

# 查看归档内容
tar -tf archive.tar                # 列出归档内容
tar -tzf archive.tar.gz            # 列出gzip归档内容
tar -tvf archive.tar               # 详细列出归档内容

# 提取归档
tar -xf archive.tar                # 提取归档
tar -xzf archive.tar.gz            # 提取gzip归档
tar -xjf archive.tar.bz2           # 提取bzip2归档
tar -xf archive.tar -C /path/to/destination/  # 提取到指定目录

# 增量归档
tar -czf backup-$(date +%Y%m%d).tar.gz --newer-mtime="1 day ago" /home/user/
```

### 其他压缩工具
```bash
#!/bin/bash

# gzip压缩
gzip file.txt                      # 压缩文件（原文件被替换）
gzip -c file.txt > file.txt.gz     # 保留原文件
gunzip file.txt.gz                 # 解压缩
zcat file.txt.gz                   # 查看压缩文件内容

# zip压缩
zip archive.zip file1 file2        # 创建zip归档
zip -r archive.zip directory/      # 递归压缩目录
unzip archive.zip                  # 解压zip文件
unzip -l archive.zip               # 列出zip文件内容

# 7zip压缩
7z a archive.7z file1 file2        # 创建7z归档
7z x archive.7z                    # 解压7z文件
7z l archive.7z                    # 列出7z文件内容
```

## 5. 文件监控

### inotify监控
```bash
#!/bin/bash

# 安装inotify-tools
# Ubuntu/Debian: apt-get install inotify-tools
# CentOS/RHEL: yum install inotify-tools

# 监控文件变化
monitor_file() {
    local file="$1"
    
    inotifywait -m -e modify,create,delete,move "$file" |
    while read path action file; do
        echo "$(date): $action detected on $file in $path"
    done
}

# 监控目录变化
monitor_directory() {
    local directory="$1"
    
    inotifywait -m -r -e modify,create,delete,move "$directory" |
    while read path action file; do
        case $action in
            CREATE)
                echo "$(date): 文件创建 - $path$file"
                ;;
            DELETE)
                echo "$(date): 文件删除 - $path$file"
                ;;
            MODIFY)
                echo "$(date): 文件修改 - $path$file"
                ;;
            MOVED_TO|MOVED_FROM)
                echo "$(date): 文件移动 - $path$file"
                ;;
        esac
    done
}

# 使用示例
# monitor_file "/var/log/syslog"
# monitor_directory "/home/user/documents"
```

### 文件变化检测
```bash
#!/bin/bash

# 基于校验和的文件监控
monitor_file_checksum() {
    local file="$1"
    local interval="${2:-5}"
    local last_checksum=""
    
    while true; do
        if [[ -f "$file" ]]; then
            local current_checksum=$(md5sum "$file" | cut -d' ' -f1)
            
            if [[ -n "$last_checksum" && "$current_checksum" != "$last_checksum" ]]; then
                echo "$(date): 文件 $file 已被修改"
                # 这里可以添加处理逻辑
            fi
            
            last_checksum="$current_checksum"
        else
            echo "$(date): 文件 $file 不存在"
        fi
        
        sleep "$interval"
    done
}

# 目录大小监控
monitor_directory_size() {
    local directory="$1"
    local threshold="$2"  # MB
    local interval="${3:-60}"
    
    while true; do
        local size=$(du -sm "$directory" 2>/dev/null | cut -f1)
        
        if [[ $size -gt $threshold ]]; then
            echo "$(date): 警告 - 目录 $directory 大小 ${size}MB 超过阈值 ${threshold}MB"
        fi
        
        sleep "$interval"
    done
}
```

## 6. 文件处理实用函数

### 批量文件处理
```bash
#!/bin/bash

# 批量重命名
batch_rename() {
    local pattern="$1"
    local replacement="$2"
    local directory="${3:-.}"
    
    find "$directory" -maxdepth 1 -type f -name "*$pattern*" | while read file; do
        local basename=$(basename "$file")
        local dirname=$(dirname "$file")
        local new_name="${basename/$pattern/$replacement}"
        
        if [[ "$basename" != "$new_name" ]]; then
            mv "$file" "$dirname/$new_name"
            echo "重命名: $basename -> $new_name"
        fi
    done
}

# 批量转换文件编码
batch_convert_encoding() {
    local from_encoding="$1"
    local to_encoding="$2"
    local pattern="$3"
    
    find . -name "$pattern" -type f | while read file; do
        local temp_file="${file}.tmp"
        
        if iconv -f "$from_encoding" -t "$to_encoding" "$file" > "$temp_file" 2>/dev/null; then
            mv "$temp_file" "$file"
            echo "转换编码: $file ($from_encoding -> $to_encoding)"
        else
            rm -f "$temp_file"
            echo "转换失败: $file"
        fi
    done
}

# 批量调整图片大小（需要ImageMagick）
batch_resize_images() {
    local size="$1"
    local quality="${2:-80}"
    local input_dir="${3:-.}"
    local output_dir="${4:-resized}"
    
    mkdir -p "$output_dir"
    
    find "$input_dir" -maxdepth 1 -type f \( -iname "*.jpg" -o -iname "*.jpeg" -o -iname "*.png" \) | while read image; do
        local basename=$(basename "$image")
        local output_file="$output_dir/$basename"
        
        if command -v convert >/dev/null; then
            convert "$image" -resize "$size" -quality "$quality" "$output_file"
            echo "调整大小: $basename -> $output_file"
        else
            echo "错误: 需要安装ImageMagick"
            break
        fi
    done
}
```

### 文件同步和备份
```bash
#!/bin/bash

# 简单文件同步
sync_directories() {
    local source="$1"
    local destination="$2"
    local delete_extra="${3:-false}"
    
    if [[ ! -d "$source" ]]; then
        echo "错误: 源目录不存在 - $source"
        return 1
    fi
    
    mkdir -p "$destination"
    
    local rsync_options="-av --progress"
    if [[ "$delete_extra" == "true" ]]; then
        rsync_options+=" --delete"
    fi
    
    rsync $rsync_options "$source/" "$destination/"
}

# 增量备份
incremental_backup() {
    local source="$1"
    local backup_base="$2"
    local backup_name="backup-$(date +%Y%m%d-%H%M%S)"
    local backup_dir="$backup_base/$backup_name"
    local latest_link="$backup_base/latest"
    
    mkdir -p "$backup_base"
    
    local rsync_options="-av --progress --delete"
    
    # 如果存在最新备份，使用硬链接节省空间
    if [[ -d "$latest_link" ]]; then
        rsync_options+=" --link-dest=$latest_link"
    fi
    
    rsync $rsync_options "$source/" "$backup_dir/"
    
    # 更新最新备份链接
    rm -f "$latest_link"
    ln -s "$backup_name" "$latest_link"
    
    echo "备份完成: $backup_dir"
}

# 清理旧备份
cleanup_old_backups() {
    local backup_base="$1"
    local keep_days="${2:-7}"
    
    find "$backup_base" -maxdepth 1 -type d -name "backup-*" -mtime +$keep_days -exec rm -rf {} \;
    echo "清理了 $keep_days 天前的备份"
}
```

## 实践练习

### 练习1：日志文件管理器
```bash
#!/bin/bash
# log_manager.sh - 日志文件管理器

LOG_DIR="/var/log"
ARCHIVE_DIR="/var/log/archive"
MAX_SIZE="100M"
MAX_AGE="30"

# 压缩大日志文件
compress_large_logs() {
    local log_dir="$1"
    local max_size="$2"
    
    echo "查找大于 $max_size 的日志文件..."
    
    find "$log_dir" -name "*.log" -size "+$max_size" -type f | while read logfile; do
        echo "压缩文件: $logfile"
        gzip "$logfile"
    done
}

# 归档旧日志文件
archive_old_logs() {
    local log_dir="$1"
    local archive_dir="$2"
    local max_age="$3"
    
    mkdir -p "$archive_dir"
    
    echo "归档 $max_age 天前的日志文件..."
    
    find "$log_dir" -name "*.log" -mtime "+$max_age" -type f | while read logfile; do
        local basename=$(basename "$logfile")
        local archive_name="${basename%.log}-$(date -r "$logfile" +%Y%m%d).log"
        
        echo "归档文件: $logfile -> $archive_dir/$archive_name"
        mv "$logfile" "$archive_dir/$archive_name"
        gzip "$archive_dir/$archive_name"
    done
}

# 清理空日志文件
cleanup_empty_logs() {
    local log_dir="$1"
    
    echo "清理空日志文件..."
    
    find "$log_dir" -name "*.log" -size 0 -type f | while read logfile; do
        echo "删除空文件: $logfile"
        rm "$logfile"
    done
}

# 生成日志统计报告
generate_log_report() {
    local log_dir="$1"
    local report_file="$2"
    
    {
        echo "日志文件统计报告"
        echo "生成时间: $(date)"
        echo "========================================"
        echo
        
        echo "日志文件总数:"
        find "$log_dir" -name "*.log" -type f | wc -l
        echo
        
        echo "日志文件总大小:"
        find "$log_dir" -name "*.log" -type f -exec ls -la {} \; | awk '{sum+=$5} END {printf "%.2f MB\n", sum/1024/1024}'
        echo
        
        echo "最大的10个日志文件:"
        find "$log_dir" -name "*.log" -type f -exec ls -la {} \; | sort -k5 -nr | head -10 | awk '{printf "%s: %.2f MB\n", $9, $5/1024/1024}'
        echo
        
        echo "最近修改的10个日志文件:"
        find "$log_dir" -name "*.log" -type f -exec ls -lt {} \; | head -10 | awk '{print $9 ": " $6 " " $7 " " $8}'
        
    } | tee "$report_file"
}

# 主函数
main() {
    case "${1:-help}" in
        compress)
            compress_large_logs "$LOG_DIR" "$MAX_SIZE"
            ;;
        archive)
            archive_old_logs "$LOG_DIR" "$ARCHIVE_DIR" "$MAX_AGE"
            ;;
        cleanup)
            cleanup_empty_logs "$LOG_DIR"
            ;;
        report)
            generate_log_report "$LOG_DIR" "${2:-log_report.txt}"
            ;;
        all)
            echo "执行完整日志管理..."
            compress_large_logs "$LOG_DIR" "$MAX_SIZE"
            archive_old_logs "$LOG_DIR" "$ARCHIVE_DIR" "$MAX_AGE"
            cleanup_empty_logs "$LOG_DIR"
            generate_log_report "$LOG_DIR" "log_report.txt"
            echo "日志管理完成"
            ;;
        help)
            echo "用法: $0 [compress|archive|cleanup|report|all] [参数]"
            echo "  compress  - 压缩大日志文件"
            echo "  archive   - 归档旧日志文件"
            echo "  cleanup   - 清理空日志文件"
            echo "  report    - 生成统计报告"
            echo "  all       - 执行所有操作"
            ;;
        *)
            echo "未知操作: $1"
            echo "使用 '$0 help' 查看帮助"
            exit 1
            ;;
    esac
}

main "$@"
```

### 练习2：文件整理工具
```bash
#!/bin/bash
# file_organizer.sh - 文件整理工具

# 按文件类型整理
organize_by_type() {
    local source_dir="$1"
    local target_dir="$2"
    
    # 定义文件类型映射
    declare -A file_types=(
        ["images"]="jpg jpeg png gif bmp svg webp"
        ["documents"]="pdf doc docx txt rtf odt"
        ["videos"]="mp4 avi mkv mov wmv flv webm"
        ["audio"]="mp3 wav flac aac ogg m4a"
        ["archives"]="zip rar 7z tar gz bz2 xz"
        ["code"]="py js html css php java cpp c sh"
    )
    
    # 创建目标目录
    for type in "${!file_types[@]}"; do
        mkdir -p "$target_dir/$type"
    done
    mkdir -p "$target_dir/others"
    
    # 整理文件
    find "$source_dir" -maxdepth 1 -type f | while read file; do
        local basename=$(basename "$file")
        local extension="${basename##*.}"
        extension=$(echo "$extension" | tr '[:upper:]' '[:lower:]')
        
        local moved=false
        for type in "${!file_types[@]}"; do
            if [[ " ${file_types[$type]} " =~ " $extension " ]]; then
                mv "$file" "$target_dir/$type/"
                echo "移动 $basename 到 $type/"
                moved=true
                break
            fi
        done
        
        if [[ "$moved" == false ]]; then
            mv "$file" "$target_dir/others/"
            echo "移动 $basename 到 others/"
        fi
    done
}

# 按日期整理
organize_by_date() {
    local source_dir="$1"
    local target_dir="$2"
    
    find "$source_dir" -maxdepth 1 -type f | while read file; do
        local basename=$(basename "$file")
        local file_date=$(date -r "$file" +%Y/%m)
        local date_dir="$target_dir/$file_date"
        
        mkdir -p "$date_dir"
        mv "$file" "$date_dir/"
        echo "移动 $basename 到 $file_date/"
    done
}

# 按大小整理
organize_by_size() {
    local source_dir="$1"
    local target_dir="$2"
    
    mkdir -p "$target_dir/small"    # < 1MB
    mkdir -p "$target_dir/medium"   # 1MB - 100MB
    mkdir -p "$target_dir/large"    # > 100MB
    
    find "$source_dir" -maxdepth 1 -type f | while read file; do
        local basename=$(basename "$file")
        local size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file")
        
        if [[ $size -lt 1048576 ]]; then
            mv "$file" "$target_dir/small/"
            echo "移动 $basename 到 small/ ($(($size/1024))KB)"
        elif [[ $size -lt 104857600 ]]; then
            mv "$file" "$target_dir/medium/"
            echo "移动 $basename 到 medium/ ($(($size/1024/1024))MB)"
        else
            mv "$file" "$target_dir/large/"
            echo "移动 $basename 到 large/ ($(($size/1024/1024))MB)"
        fi
    done
}

# 清理重复文件
remove_duplicates() {
    local directory="$1"
    local duplicate_dir="$2"
    
    mkdir -p "$duplicate_dir"
    
    # 使用MD5校验和查找重复文件
    declare -A checksums
    
    find "$directory" -type f | while read file; do
        local checksum=$(md5sum "$file" | cut -d' ' -f1)
        local basename=$(basename "$file")
        
        if [[ -n "${checksums[$checksum]}" ]]; then
            echo "发现重复文件: $basename (与 ${checksums[$checksum]} 相同)"
            mv "$file" "$duplicate_dir/"
        else
            checksums[$checksum]="$basename"
        fi
    done
}

# 主函数
main() {
    local operation="$1"
    local source_dir="$2"
    local target_dir="$3"
    
    if [[ $# -lt 2 ]]; then
        echo "用法: $0 <操作> <源目录> [目标目录]"
        echo "操作:"
        echo "  type     - 按文件类型整理"
        echo "  date     - 按修改日期整理"
        echo "  size     - 按文件大小整理"
        echo "  duplicates - 清理重复文件"
        exit 1
    fi
    
    if [[ ! -d "$source_dir" ]]; then
        echo "错误: 源目录不存在 - $source_dir"
        exit 1
    fi
    
    target_dir="${target_dir:-${source_dir}_organized}"
    mkdir -p "$target_dir"
    
    case "$operation" in
        type)
            organize_by_type "$source_dir" "$target_dir"
            ;;
        date)
            organize_by_date "$source_dir" "$target_dir"
            ;;
        size)
            organize_by_size "$source_dir" "$target_dir"
            ;;
        duplicates)
            remove_duplicates "$source_dir" "${target_dir}/duplicates"
            ;;
        *)
            echo "未知操作: $operation"
            exit 1
            ;;
    esac
    
    echo "文件整理完成！"
}

main "$@"
```

## 最佳实践

1. **安全操作**：重要操作前先备份
2. **权限检查**：操作前检查文件权限
3. **错误处理**：处理文件不存在等异常情况
4. **原子操作**：使用临时文件确保操作完整性
5. **资源清理**：及时关闭文件描述符
6. **路径处理**：正确处理包含空格的文件名
7. **性能优化**：大量文件操作时考虑并行处理