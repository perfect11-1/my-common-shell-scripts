# 字符串处理详解

## 1. 字符串基础操作

### 字符串定义和基本操作
```bash
#!/bin/bash

# 字符串定义
str1="Hello World"
str2='Single quotes'
str3="包含变量: $USER"
str4='不解析变量: $USER'

# 字符串长度
echo "字符串长度: ${#str1}"

# 字符串连接
first_name="张"
last_name="三"
full_name="$first_name$last_name"
full_name="${first_name}${last_name}"  # 推荐写法

echo "全名: $full_name"

# 字符串比较
if [[ "$str1" == "Hello World" ]]; then
    echo "字符串相等"
fi

if [[ "$str1" != "$str2" ]]; then
    echo "字符串不相等"
fi

# 字典序比较
if [[ "$str1" < "$str2" ]]; then
    echo "$str1 在字典序中小于 $str2"
fi
```

### 字符串截取
```bash
#!/bin/bash

text="Hello World, Welcome to Shell Programming"

# 从左边截取
echo "${text:0:5}"      # Hello (从位置0开始，长度5)
echo "${text:6}"        # World, Welcome to Shell Programming (从位置6到结尾)
echo "${text:6:5}"      # World (从位置6开始，长度5)

# 从右边截取
echo "${text: -11}"     # Programming (最后11个字符)
echo "${text: -11:7}"   # Program (从倒数第11个字符开始，长度7)

# 使用变量作为位置
start=6
length=5
echo "${text:$start:$length}"  # World
```

### 字符串删除和替换
```bash
#!/bin/bash

filename="document.backup.txt"

# 删除匹配的最短前缀
echo "${filename#*.}"        # backup.txt (删除第一个.及之前的内容)

# 删除匹配的最长前缀
echo "${filename##*.}"       # txt (删除最后一个.及之前的内容)

# 删除匹配的最短后缀
echo "${filename%.*}"        # document.backup (删除最后一个.及之后的内容)

# 删除匹配的最长后缀
echo "${filename%%.*}"       # document (删除第一个.及之后的内容)

# 字符串替换
path="/home/user/documents/file.txt"
echo "${path/user/admin}"    # /home/admin/documents/file.txt (替换第一个匹配)
echo "${path//o/O}"          # /hOme/user/dOcuments/file.txt (替换所有匹配)

# 位置替换
echo "${path/#\/home/\/root}" # /root/user/documents/file.txt (替换开头)
echo "${path/%txt/pdf}"       # /home/user/documents/file.pdf (替换结尾)
```

## 2. 大小写转换

### 内置大小写转换
```bash
#!/bin/bash

text="Hello World"

# 转换为大写
echo "${text^^}"            # HELLO WORLD (全部大写)
echo "${text^}"             # Hello World (首字母大写)
echo "${text^^[hw]}"        # Hello World (指定字符大写)

# 转换为小写
echo "${text,,}"            # hello world (全部小写)
echo "${text,}"             # hello World (首字母小写)
echo "${text,,[HW]}"        # hello world (指定字符小写)

# 切换大小写
echo "${text~~}"            # hELLO wORLD (大小写切换)
echo "${text~}"             # hello World (首字母切换)
```

### 使用外部工具转换
```bash
#!/bin/bash

text="Hello World"

# 使用tr命令
echo "$text" | tr '[:lower:]' '[:upper:]'  # HELLO WORLD
echo "$text" | tr '[:upper:]' '[:lower:]'  # hello world
echo "$text" | tr 'a-z' 'A-Z'             # HELLO WORLD

# 使用awk
echo "$text" | awk '{print toupper($0)}'  # HELLO WORLD
echo "$text" | awk '{print tolower($0)}'  # hello world

# 使用sed
echo "$text" | sed 's/.*/\U&/'            # HELLO WORLD
echo "$text" | sed 's/.*/\L&/'            # hello world
```

## 3. 字符串搜索和匹配

### 模式匹配
```bash
#!/bin/bash

text="Hello World 123"

# 通配符匹配
if [[ $text == *"World"* ]]; then
    echo "包含 World"
fi

if [[ $text == Hello* ]]; then
    echo "以 Hello 开头"
fi

if [[ $text == *123 ]]; then
    echo "以 123 结尾"
fi

# 字符类匹配
if [[ $text == *[0-9]* ]]; then
    echo "包含数字"
fi

if [[ $text == *[[:alpha:]]* ]]; then
    echo "包含字母"
fi

# 正则表达式匹配
if [[ $text =~ ^Hello.*[0-9]+$ ]]; then
    echo "匹配正则表达式"
fi
```

### 字符串查找
```bash
#!/bin/bash

# 查找子字符串位置
find_substring() {
    local string="$1"
    local substring="$2"
    local pos=0
    
    while [[ $pos -lt ${#string} ]]; do
        if [[ "${string:$pos:${#substring}}" == "$substring" ]]; then
            echo $pos
            return 0
        fi
        ((pos++))
    done
    
    echo -1  # 未找到
}

text="Hello World Hello"
pos=$(find_substring "$text" "World")
echo "World 在位置: $pos"

# 查找所有匹配位置
find_all_occurrences() {
    local string="$1"
    local substring="$2"
    local pos=0
    local found=false
    
    while [[ $pos -le $((${#string} - ${#substring})) ]]; do
        if [[ "${string:$pos:${#substring}}" == "$substring" ]]; then
            echo $pos
            found=true
        fi
        ((pos++))
    done
    
    if [[ "$found" == false ]]; then
        echo "未找到"
    fi
}

echo "Hello 的所有位置:"
find_all_occurrences "$text" "Hello"
```

## 4. 字符串分割和连接

### 字符串分割
```bash
#!/bin/bash

# 使用IFS分割
split_string() {
    local string="$1"
    local delimiter="$2"
    local -a result=()
    
    IFS="$delimiter" read -ra result <<< "$string"
    printf '%s\n' "${result[@]}"
}

# 示例
data="apple,banana,orange,grape"
echo "分割结果:"
split_string "$data" ","

# 分割为数组
IFS=',' read -ra fruits <<< "$data"
for fruit in "${fruits[@]}"; do
    echo "水果: $fruit"
done

# 使用cut命令分割
echo "$data" | cut -d',' -f1    # apple (第1个字段)
echo "$data" | cut -d',' -f2-4  # banana,orange,grape (第2-4个字段)

# 使用awk分割
echo "$data" | awk -F',' '{for(i=1;i<=NF;i++) print $i}'
```

### 字符串连接
```bash
#!/bin/bash

# 数组连接为字符串
join_array() {
    local delimiter="$1"
    shift
    local first="$1"
    shift
    printf "%s" "$first" "${@/#/$delimiter}"
}

fruits=("apple" "banana" "orange")
result=$(join_array "," "${fruits[@]}")
echo "连接结果: $result"

# 使用printf连接
join_with_printf() {
    local IFS="$1"
    shift
    echo "$*"
}

result2=$(join_with_printf "," "${fruits[@]}")
echo "连接结果2: $result2"
```

## 5. 字符串验证

### 常用验证函数
```bash
#!/bin/bash

# 验证是否为数字
is_number() {
    local input="$1"
    [[ $input =~ ^-?[0-9]+$ ]]
}

# 验证是否为浮点数
is_float() {
    local input="$1"
    [[ $input =~ ^-?[0-9]+\.?[0-9]*$ ]]
}

# 验证邮箱地址
is_email() {
    local email="$1"
    [[ $email =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]
}

# 验证IP地址
is_ip() {
    local ip="$1"
    local pattern='^([0-9]{1,3}\.){3}[0-9]{1,3}$'
    
    if [[ $ip =~ $pattern ]]; then
        IFS='.' read -ra octets <<< "$ip"
        for octet in "${octets[@]}"; do
            if [[ $octet -gt 255 ]]; then
                return 1
            fi
        done
        return 0
    fi
    return 1
}

# 验证手机号码
is_phone() {
    local phone="$1"
    [[ $phone =~ ^1[3-9][0-9]{9}$ ]]
}

# 验证身份证号码
is_id_card() {
    local id="$1"
    [[ $id =~ ^[0-9]{17}[0-9Xx]$ ]]
}

# 测试验证函数
test_validations() {
    echo "=== 字符串验证测试 ==="
    
    # 测试数字
    test_cases=("123" "-456" "12.34" "abc" "12a")
    for case in "${test_cases[@]}"; do
        if is_number "$case"; then
            echo "$case 是整数"
        elif is_float "$case"; then
            echo "$case 是浮点数"
        else
            echo "$case 不是数字"
        fi
    done
    
    # 测试邮箱
    emails=("user@example.com" "invalid.email" "test@domain.co.uk")
    for email in "${emails[@]}"; do
        if is_email "$email"; then
            echo "$email 是有效邮箱"
        else
            echo "$email 是无效邮箱"
        fi
    done
    
    # 测试IP地址
    ips=("192.168.1.1" "256.1.1.1" "10.0.0.1" "invalid.ip")
    for ip in "${ips[@]}"; do
        if is_ip "$ip"; then
            echo "$ip 是有效IP地址"
        else
            echo "$ip 是无效IP地址"
        fi
    done
}

# test_validations
```

## 6. 高级字符串处理

### 字符串编码和解码
```bash
#!/bin/bash

# URL编码
url_encode() {
    local string="$1"
    local encoded=""
    local char
    
    for ((i=0; i<${#string}; i++)); do
        char="${string:$i:1}"
        case $char in
            [a-zA-Z0-9.~_-])
                encoded+="$char"
                ;;
            *)
                encoded+=$(printf '%%%02X' "'$char")
                ;;
        esac
    done
    
    echo "$encoded"
}

# URL解码
url_decode() {
    local string="$1"
    echo -e "${string//%/\\x}"
}

# Base64编码
base64_encode() {
    local string="$1"
    echo -n "$string" | base64
}

# Base64解码
base64_decode() {
    local string="$1"
    echo "$string" | base64 -d
}

# HTML实体编码
html_encode() {
    local string="$1"
    string="${string//&/&amp;}"
    string="${string//</&lt;}"
    string="${string//>/&gt;}"
    string="${string//\"/&quot;}"
    string="${string//\'/&#39;}"
    echo "$string"
}

# 测试编码解码
test_encoding() {
    original="Hello World & <test>"
    
    echo "原始字符串: $original"
    
    # URL编码测试
    encoded=$(url_encode "$original")
    decoded=$(url_decode "$encoded")
    echo "URL编码: $encoded"
    echo "URL解码: $decoded"
    
    # Base64编码测试
    b64_encoded=$(base64_encode "$original")
    b64_decoded=$(base64_decode "$b64_encoded")
    echo "Base64编码: $b64_encoded"
    echo "Base64解码: $b64_decoded"
    
    # HTML编码测试
    html_encoded=$(html_encode "$original")
    echo "HTML编码: $html_encoded"
}

# test_encoding
```

### 字符串模板处理
```bash
#!/bin/bash

# 简单模板替换
template_replace() {
    local template="$1"
    shift
    
    # 参数应该是 key=value 的形式
    while [[ $# -gt 0 ]]; do
        local key="${1%%=*}"
        local value="${1#*=}"
        template="${template//\{\{$key\}\}/$value}"
        shift
    done
    
    echo "$template"
}

# 高级模板处理
process_template() {
    local template_file="$1"
    local output_file="$2"
    shift 2
    
    local content=$(cat "$template_file")
    
    # 处理变量替换
    while [[ $# -gt 0 ]]; do
        local key="${1%%=*}"
        local value="${1#*=}"
        content="${content//\{\{$key\}\}/$value}"
        shift
    done
    
    # 处理条件语句 {{#if condition}}...{{/if}}
    # 这里是简化版本，实际实现会更复杂
    
    echo "$content" > "$output_file"
}

# 使用示例
template="Hello {{name}}, welcome to {{place}}!"
result=$(template_replace "$template" "name=张三" "place=北京")
echo "$result"
```

## 7. 文本处理工具集成

### 使用sed进行高级文本处理
```bash
#!/bin/bash

# 多行替换
multiline_replace() {
    local file="$1"
    local pattern="$2"
    local replacement="$3"
    
    sed -i "s/$pattern/$replacement/g" "$file"
}

# 删除空行
remove_empty_lines() {
    local file="$1"
    sed -i '/^$/d' "$file"
}

# 删除注释行
remove_comments() {
    local file="$1"
    local comment_char="${2:-#}"
    sed -i "/^[[:space:]]*$comment_char/d" "$file"
}

# 在指定行前后插入内容
insert_before_line() {
    local file="$1"
    local line_number="$2"
    local content="$3"
    
    sed -i "${line_number}i\\$content" "$file"
}

insert_after_line() {
    local file="$1"
    local line_number="$2"
    local content="$3"
    
    sed -i "${line_number}a\\$content" "$file"
}
```

### 使用awk进行数据处理
```bash
#!/bin/bash

# 处理CSV文件
process_csv() {
    local csv_file="$1"
    local column="$2"
    
    # 计算指定列的总和
    awk -F',' -v col="$column" '
        NR > 1 { sum += $col }
        END { print "总和:", sum }
    ' "$csv_file"
    
    # 计算平均值
    awk -F',' -v col="$column" '
        NR > 1 { sum += $col; count++ }
        END { print "平均值:", sum/count }
    ' "$csv_file"
}

# 格式化输出
format_table() {
    local file="$1"
    local delimiter="${2:-,}"
    
    awk -F"$delimiter" '
    {
        for(i=1; i<=NF; i++) {
            printf "%-15s", $i
        }
        print ""
    }' "$file"
}

# 提取特定模式的行
extract_pattern() {
    local file="$1"
    local pattern="$2"
    
    awk "/$pattern/ { print NR \":\" \$0 }" "$file"
}
```

## 实践练习

### 练习1：日志分析器
```bash
#!/bin/bash
# log_analyzer.sh - 日志分析器

# 分析Apache访问日志
analyze_apache_log() {
    local log_file="$1"
    local output_dir="${2:-./analysis}"
    
    mkdir -p "$output_dir"
    
    echo "分析Apache访问日志: $log_file"
    
    # 提取IP地址并统计
    echo "=== TOP 10 访问IP ===" > "$output_dir/top_ips.txt"
    awk '{print $1}' "$log_file" | sort | uniq -c | sort -nr | head -10 >> "$output_dir/top_ips.txt"
    
    # 提取请求URL并统计
    echo "=== TOP 10 请求URL ===" > "$output_dir/top_urls.txt"
    awk '{print $7}' "$log_file" | sort | uniq -c | sort -nr | head -10 >> "$output_dir/top_urls.txt"
    
    # 分析HTTP状态码
    echo "=== HTTP状态码统计 ===" > "$output_dir/status_codes.txt"
    awk '{print $9}' "$log_file" | sort | uniq -c | sort -nr >> "$output_dir/status_codes.txt"
    
    # 分析用户代理
    echo "=== 用户代理统计 ===" > "$output_dir/user_agents.txt"
    awk -F'"' '{print $6}' "$log_file" | sort | uniq -c | sort -nr | head -20 >> "$output_dir/user_agents.txt"
    
    # 按小时统计访问量
    echo "=== 按小时访问量 ===" > "$output_dir/hourly_stats.txt"
    awk '{
        match($4, /\[([0-9]{2}\/[A-Za-z]{3}\/[0-9]{4}):([0-9]{2})/, arr)
        if (arr[1] && arr[2]) {
            hour_count[arr[1] " " arr[2] ":00"]++
        }
    }
    END {
        for (hour in hour_count) {
            print hour_count[hour], hour
        }
    }' "$log_file" | sort -nr >> "$output_dir/hourly_stats.txt"
    
    # 分析响应大小
    echo "=== 响应大小统计 ===" > "$output_dir/response_sizes.txt"
    awk '{
        size = $10
        if (size == "-") size = 0
        total_size += size
        count++
        if (size > max_size) max_size = size
        if (min_size == 0 || size < min_size) min_size = size
    }
    END {
        print "总请求数:", count
        print "总传输量:", total_size " bytes (" total_size/1024/1024 " MB)"
        print "平均响应大小:", total_size/count " bytes"
        print "最大响应大小:", max_size " bytes"
        print "最小响应大小:", min_size " bytes"
    }' "$log_file" >> "$output_dir/response_sizes.txt"
    
    echo "分析完成，结果保存在 $output_dir 目录"
}

# 分析错误日志
analyze_error_log() {
    local log_file="$1"
    local output_file="${2:-error_analysis.txt}"
    
    {
        echo "错误日志分析报告"
        echo "文件: $log_file"
        echo "生成时间: $(date)"
        echo "========================================"
        echo
        
        echo "=== 错误级别统计 ==="
        grep -oE '\[(error|warn|notice|info|debug)\]' "$log_file" | sort | uniq -c | sort -nr
        echo
        
        echo "=== 最常见的错误 ==="
        grep -E '\[error\]' "$log_file" | sed 's/.*\[error\] //' | sort | uniq -c | sort -nr | head -10
        echo
        
        echo "=== 按日期统计错误 ==="
        grep -E '\[error\]' "$log_file" | awk '{print $1}' | sort | uniq -c
        echo
        
        echo "=== 最近的错误 ==="
        grep -E '\[error\]' "$log_file" | tail -20
        
    } > "$output_file"
    
    echo "错误日志分析完成，结果保存在 $output_file"
}

# 主函数
main() {
    case "${1:-help}" in
        apache)
            if [[ -z "$2" ]]; then
                echo "用法: $0 apache <日志文件> [输出目录]"
                exit 1
            fi
            analyze_apache_log "$2" "$3"
            ;;
        error)
            if [[ -z "$2" ]]; then
                echo "用法: $0 error <错误日志文件> [输出文件]"
                exit 1
            fi
            analyze_error_log "$2" "$3"
            ;;
        help)
            echo "用法: $0 <类型> <日志文件> [输出]"
            echo "类型:"
            echo "  apache  - 分析Apache访问日志"
            echo "  error   - 分析错误日志"
            ;;
        *)
            echo "未知类型: $1"
            echo "使用 '$0 help' 查看帮助"
            exit 1
            ;;
    esac
}

main "$@"
```

### 练习2：配置文件处理器
```bash
#!/bin/bash
# config_processor.sh - 配置文件处理器

# 读取配置文件
read_config() {
    local config_file="$1"
    declare -gA config
    
    while IFS='=' read -r key value; do
        # 跳过注释和空行
        [[ $key =~ ^[[:space:]]*# ]] && continue
        [[ -z $key ]] && continue
        
        # 去除前后空格和引号
        key=$(echo "$key" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        value=$(echo "$value" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//;s/^["'\'']*//;s/["'\'']*$//')
        
        config["$key"]="$value"
    done < "$config_file"
}

# 写入配置文件
write_config() {
    local config_file="$1"
    local backup="${config_file}.bak.$(date +%Y%m%d_%H%M%S)"
    
    # 备份原文件
    if [[ -f "$config_file" ]]; then
        cp "$config_file" "$backup"
        echo "原配置已备份到: $backup"
    fi
    
    # 写入新配置
    {
        echo "# 配置文件"
        echo "# 生成时间: $(date)"
        echo
        
        for key in "${!config[@]}"; do
            echo "$key = ${config[$key]}"
        done
    } > "$config_file"
}

# 更新配置项
update_config() {
    local key="$1"
    local value="$2"
    
    config["$key"]="$value"
    echo "更新配置: $key = $value"
}

# 删除配置项
delete_config() {
    local key="$1"
    
    if [[ -n "${config[$key]}" ]]; then
        unset config["$key"]
        echo "删除配置: $key"
    else
        echo "配置项不存在: $key"
    fi
}

# 显示配置
show_config() {
    local filter="$1"
    
    echo "=== 配置信息 ==="
    for key in "${!config[@]}"; do
        if [[ -z "$filter" || "$key" =~ $filter ]]; then
            echo "$key = ${config[$key]}"
        fi
    done
}

# 验证配置
validate_config() {
    local errors=0
    
    echo "=== 配置验证 ==="
    
    # 检查必需的配置项
    local required_keys=("database_host" "database_port" "database_name")
    for key in "${required_keys[@]}"; do
        if [[ -z "${config[$key]}" ]]; then
            echo "错误: 缺少必需配置 - $key"
            ((errors++))
        fi
    done
    
    # 验证端口号
    if [[ -n "${config[database_port]}" ]]; then
        if ! [[ "${config[database_port]}" =~ ^[0-9]+$ ]] || [[ "${config[database_port]}" -lt 1 ]] || [[ "${config[database_port]}" -gt 65535 ]]; then
            echo "错误: 无效的端口号 - ${config[database_port]}"
            ((errors++))
        fi
    fi
    
    # 验证邮箱地址
    if [[ -n "${config[admin_email]}" ]]; then
        if ! [[ "${config[admin_email]}" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]; then
            echo "错误: 无效的邮箱地址 - ${config[admin_email]}"
            ((errors++))
        fi
    fi
    
    if [[ $errors -eq 0 ]]; then
        echo "配置验证通过"
    else
        echo "发现 $errors 个错误"
    fi
    
    return $errors
}

# 配置模板生成
generate_template() {
    local template_file="$1"
    
    cat > "$template_file" << 'EOF'
# 应用配置文件模板
# 请根据实际情况修改以下配置

# 数据库配置
database_host = localhost
database_port = 3306
database_name = myapp
database_user = root
database_password = password

# 应用配置
app_name = MyApplication
app_version = 1.0.0
app_debug = false

# 服务器配置
server_host = 0.0.0.0
server_port = 8080
server_workers = 4

# 日志配置
log_level = info
log_file = /var/log/myapp.log
log_max_size = 100MB

# 邮件配置
smtp_host = smtp.example.com
smtp_port = 587
smtp_user = noreply@example.com
smtp_password = password
admin_email = admin@example.com

# 缓存配置
cache_type = redis
cache_host = localhost
cache_port = 6379
cache_db = 0
EOF

    echo "配置模板已生成: $template_file"
}

# 主函数
main() {
    local config_file="$1"
    local action="$2"
    
    if [[ -z "$config_file" ]]; then
        echo "用法: $0 <配置文件> <操作> [参数...]"
        echo "操作:"
        echo "  show [过滤器]     - 显示配置"
        echo "  set <键> <值>     - 设置配置"
        echo "  get <键>          - 获取配置"
        echo "  delete <键>       - 删除配置"
        echo "  validate          - 验证配置"
        echo "  template          - 生成配置模板"
        exit 1
    fi
    
    case "$action" in
        show)
            if [[ -f "$config_file" ]]; then
                read_config "$config_file"
                show_config "$3"
            else
                echo "配置文件不存在: $config_file"
            fi
            ;;
        set)
            if [[ $# -lt 4 ]]; then
                echo "用法: $0 $config_file set <键> <值>"
                exit 1
            fi
            if [[ -f "$config_file" ]]; then
                read_config "$config_file"
            fi
            update_config "$3" "$4"
            write_config "$config_file"
            ;;
        get)
            if [[ $# -lt 3 ]]; then
                echo "用法: $0 $config_file get <键>"
                exit 1
            fi
            if [[ -f "$config_file" ]]; then
                read_config "$config_file"
                echo "${config[$3]}"
            else
                echo "配置文件不存在: $config_file"
            fi
            ;;
        delete)
            if [[ $# -lt 3 ]]; then
                echo "用法: $0 $config_file delete <键>"
                exit 1
            fi
            if [[ -f "$config_file" ]]; then
                read_config "$config_file"
                delete_config "$3"
                write_config "$config_file"
            else
                echo "配置文件不存在: $config_file"
            fi
            ;;
        validate)
            if [[ -f "$config_file" ]]; then
                read_config "$config_file"
                validate_config
            else
                echo "配置文件不存在: $config_file"
            fi
            ;;
        template)
            generate_template "$config_file"
            ;;
        *)
            echo "未知操作: $action"
            exit 1
            ;;
    esac
}

main "$@"
```

## 最佳实践

1. **引号使用**：处理包含空格的字符串时使用双引号
2. **变量替换**：使用 `${var}` 形式明确变量边界
3. **输入验证**：处理用户输入前进行验证
4. **编码处理**：注意字符编码问题，特别是中文
5. **性能考虑**：大量字符串操作时考虑使用外部工具
6. **错误处理**：处理字符串操作可能的异常情况
7. **可读性**：复杂的字符串处理逻辑要添加注释说明