# 循环结构详解

## 1. for循环

### 基本for循环
```bash
#!/bin/bash

# 遍历列表
for item in apple banana orange; do
    echo "水果: $item"
done

# 遍历数组
fruits=("苹果" "香蕉" "橙子" "葡萄")
for fruit in "${fruits[@]}"; do
    echo "水果: $fruit"
done

# 遍历文件
for file in *.txt; do
    if [[ -f "$file" ]]; then
        echo "处理文件: $file"
    fi
done
```

### C风格for循环
```bash
#!/bin/bash

# 基本数值循环
for ((i=1; i<=10; i++)); do
    echo "数字: $i"
done

# 步长循环
for ((i=0; i<=100; i+=10)); do
    echo "步长10: $i"
done

# 倒序循环
for ((i=10; i>=1; i--)); do
    echo "倒数: $i"
done

# 嵌套循环 - 乘法表
for ((i=1; i<=9; i++)); do
    for ((j=1; j<=i; j++)); do
        printf "%d×%d=%2d " $j $i $((i*j))
    done
    echo
done
```

### 遍历命令输出
```bash
#!/bin/bash

# 遍历文件列表
for file in $(ls *.log 2>/dev/null); do
    echo "日志文件: $file"
done

####################################################################################################
# 更安全的方式 - 使用数组
mapfile -t log_files < <(find . -name "*.log" -type f)
for file in "${log_files[@]}"; do
    echo "处理日志: $file"
done
####################################################################################################

# 遍历进程
for pid in $(pgrep -f "python"); do
    echo "Python进程: $pid"
done
```

## 2. while循环

### 基本while循环
```bash
#!/bin/bash

# 计数循环
count=1
while [[ $count -le 5 ]]; do
    echo "计数: $count"
    ((count++))
done

# 条件循环
read -p "请输入密码: " password
while [[ "$password" != "123456" ]]; do
    echo "密码错误，请重新输入"
    read -p "请输入密码: " password
done
echo "密码正确！"
```

### 读取文件内容
```bash
#!/bin/bash

# 逐行读取文件
while IFS= read -r line; do
    echo "处理行: $line"
done < "input.txt"

# 处理CSV文件
while IFS=',' read -r name age city; do
    echo "姓名: $name, 年龄: $age, 城市: $city"
done < "users.csv"

# 跳过标题行
{
    read  # 跳过第一行
    while IFS=',' read -r name age city; do
        echo "姓名: $name, 年龄: $age, 城市: $city"
    done
} < "users.csv"
```

### 无限循环
```bash
#!/bin/bash

# 服务监控循环
while true; do
    if pgrep -f "my_service" > /dev/null; then
        echo "$(date): 服务运行正常"
    else
        echo "$(date): 服务已停止，正在重启..."
        systemctl start my_service
    fi
    sleep 60
done

# 用户菜单循环
while true; do
    echo "=== 主菜单 ==="
    echo "1. 查看状态"
    echo "2. 启动服务"
    echo "3. 停止服务"
    echo "4. 退出"
    read -p "请选择操作: " choice
    
    case $choice in
        1) echo "查看状态..." ;;
        2) echo "启动服务..." ;;
        3) echo "停止服务..." ;;
        4) echo "再见！"; break ;;
        *) echo "无效选择，请重新输入" ;;
    esac
    echo
done
```

## 3. until循环

### 基本until循环
```bash
#!/bin/bash

# until循环 - 条件为假时执行
count=1
until [[ $count -gt 5 ]]; do
    echo "计数: $count"
    ((count++))
done

# 等待文件出现
until [[ -f "ready.flag" ]]; do
    echo "等待文件出现..."
    sleep 1
done
echo "文件已出现！"

# 等待服务启动
until curl -s http://localhost:8080/health > /dev/null; do
    echo "等待服务启动..."
    sleep 2
done
echo "服务已启动！"
```

## 4. 循环控制

### break和continue
```bash
#!/bin/bash

# break - 跳出循环
for i in {1..10}; do
    if [[ $i -eq 6 ]]; then
        echo "遇到6，跳出循环"
        break
    fi
    echo "数字: $i"
done

# continue - 跳过当前迭代
for i in {1..10}; do
    if [[ $((i % 2)) -eq 0 ]]; then
        continue  # 跳过偶数
    fi
    echo "奇数: $i"
done

# 嵌套循环中的break
for i in {1..3}; do
    echo "外层循环: $i"
    for j in {1..5}; do
        if [[ $j -eq 3 ]]; then
            break  # 只跳出内层循环
        fi
        echo "  内层循环: $j"
    done
done
```

### 带标签的break
```bash
#!/bin/bash

# 使用标签跳出多层循环
outer_loop: for i in {1..3}; do
    echo "外层: $i"
    for j in {1..3}; do
        echo "  内层: $j"
        if [[ $i -eq 2 && $j -eq 2 ]]; then
            break outer_loop  # 跳出外层循环
        fi
    done
done
echo "循环结束"
```

## 5. 循环与管道

### 循环输出到管道
```bash
#!/bin/bash

# 循环输出排序
for i in {10..1}; do
    echo $i
done | sort -n

# 循环输出过滤
for file in *.txt; do
    echo "$file: $(wc -l < "$file") lines"
done | grep -v "0 lines"

# 循环输出统计
for user in $(cut -d: -f1 /etc/passwd); do
    echo $user
done | wc -l

# -d: 选项
# -d = delimiter（分隔符）
# : = 指定冒号作为字段分隔符
# 告诉cut命令按冒号来分割每一行
# -f1 选项
# -f = field（字段）
# 1 = 第一个字段
# 提取分割后的第一个字段
```

### 管道输入到循环
```bash
#!/bin/bash

# 处理命令输出
ps aux | while read user pid cpu mem vsz rss tty stat start time command; do
    if [[ $cpu > 10.0 ]]; then
        echo "高CPU进程: $pid ($command) - $cpu%"
    fi
done

# 这行代码将每行输出按空格分割，分别赋值给11个变量：
# user - 用户名 (USER)
# pid - 进程ID (PID)
# cpu - CPU使用率 (%CPU)
# mem - 内存使用率 (%MEM)
# vsz - 虚拟内存大小 (VSZ)
# rss - 物理内存大小 (RSS)
# tty - 终端 (TTY)
# stat - 进程状态 (STAT)
# start - 启动时间 (START)
# time - 运行时间 (TIME)
# command - 命令 (COMMAND)

# 处理文件列表
find /var/log -name "*.log" -type f | while read logfile; do
    size=$(stat -f%z "$logfile" 2>/dev/null || stat -c%s "$logfile")
    if [[ $size -gt 1048576 ]]; then  # 大于1MB
        echo "大日志文件: $logfile ($(($size/1024/1024))MB)"
    fi
done
```

## 6. 高级循环技巧

### 并行处理
```bash
#!/bin/bash

# 后台并行处理
process_file() {
    local file=$1
    echo "处理文件: $file"
    # 模拟处理时间
    sleep 2
    echo "完成处理: $file"
}

# 并行处理多个文件
for file in *.txt; do
    process_file "$file" &  # 后台执行
done

wait  # 等待所有后台任务完成
echo "所有文件处理完成"
```

### 限制并发处理
```bash
#!/bin/bash
# 限制并发数量
process_file() {
    local file=$1
    echo "处理文件: $file"
    # 模拟处理时间
    sleep 2
    echo "完成处理: $file"
}
max_jobs=3
job_count=0

for file in *.md; do
    if [[ $job_count -ge $max_jobs ]]; then
        wait -n  # 等待任意一个任务完成
        ((job_count--))
    fi
    
    process_file "$file" &
    ((job_count++))
done

wait  # 等待剩余任务完成
```

### 循环中的错误处理
```bash
#!/bin/bash

# 错误处理循环
process_files() {
    local error_count=0
    local success_count=0
    
    for file in *.txt; do
        if [[ ! -e "$file" ]]; then
            echo "错误: 文件不存在 - $file" >&2
            ((error_count++))
            continue
        fi
        
        if ! process_single_file "$file"; then
            echo "错误: 处理失败 - $file" >&2
            ((error_count++))
        else
            echo "成功: 处理完成 - $file"
            ((success_count++))
        fi
    done
    
    echo "处理结果: 成功 $success_count, 失败 $error_count"
    return $error_count
}

process_single_file() {
    local file=$1
    # 模拟处理逻辑
    if [[ $(wc -l < "$file") -gt 0 ]]; then
        return 0  # 成功
    else
        return 1  # 失败
    fi
}
```

## 实践练习

### 练习1：批量文件重命名工具
```bash
#!/bin/bash
# batch_rename.sh - 批量重命名工具

show_help() {
    cat << EOF
用法: $0 [选项] <模式> <替换>

选项:
    -d, --directory DIR    指定目录 (默认: 当前目录)
    -e, --extension EXT    指定文件扩展名
    -r, --recursive        递归处理子目录
    -n, --dry-run          预览模式，不实际重命名
    -h, --help             显示帮助信息

示例:
    $0 "IMG_" "Photo_"                    # 将IMG_替换为Photo_
    $0 -e jpg -r "DSC" "Picture"          # 递归处理jpg文件
    $0 -n " " "_"                         # 预览：空格替换为下划线
EOF
}

main() {
    local directory="."
    local extension=""
    local recursive=false
    local dry_run=false
    local pattern=""
    local replacement=""
    
    # 参数解析
    while [[ $# -gt 0 ]]; do
        case $1 in
            -d|--directory)
                directory="$2"
                shift 2
                ;;
            -e|--extension)
                extension="$2"
                shift 2
                ;;
            -r|--recursive)
                recursive=true
                shift
                ;;
            -n|--dry-run)
                dry_run=true
                shift
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            -*)
                echo "未知选项: $1" >&2
                exit 1
                ;;
            *)
                if [[ -z $pattern ]]; then
                    pattern="$1"
                elif [[ -z $replacement ]]; then
                    replacement="$1"
                else
                    echo "多余参数: $1" >&2
                    exit 1
                fi
                shift
                ;;
        esac
    done
    
    # 验证参数
    if [[ -z $pattern ]]; then
        echo "错误: 请提供搜索模式" >&2
        show_help
        exit 1
    fi
    
    if [[ -z $replacement ]]; then
        replacement=""
    fi
    
    if [[ ! -d $directory ]]; then
        echo "错误: 目录不存在 - $directory" >&2
        exit 1
    fi
    
    # 构建find命令
    local find_cmd="find \"$directory\""
    if [[ $recursive == false ]]; then
        find_cmd+=" -maxdepth 1"
    fi
    find_cmd+=" -type f"
    if [[ -n $extension ]]; then
        find_cmd+=" -name \"*.$extension\""
    fi
    
    # 处理文件
    local count=0
    while IFS= read -r -d '' file; do   #-d '': 使用null字符分隔文件名
        local basename=$(basename "$file")
        local dirname=$(dirname "$file")
    
        
        # 检查文件名是否包含模式
        if [[ $basename == *"$pattern"* ]]; then
            local new_basename="${basename//$pattern/$replacement}"
            local new_file="$dirname/$new_basename"
            
            if [[ $dry_run == true ]]; then
                echo "[预览] $file -> $new_file"
            else
                if mv "$file" "$new_file" 2>/dev/null; then
                    echo "重命名: $file -> $new_file"
                else
                    echo "错误: 无法重命名 $file" >&2
                fi
            fi
            ((count++))
        fi
    done < <(eval "$find_cmd -print0")  #print0:将find查到的文件使用**null字符分隔每个文件名,null字符在文件名中是不允许的，所以是安全的分隔符
    
    if [[ $dry_run == true ]]; then
        echo "预览完成，共 $count 个文件将被重命名"
    else
        echo "重命名完成，共处理 $count 个文件"
    fi
}

main "$@"
```

### 练习2：系统监控脚本
```bash
#!/bin/bash
# system_monitor.sh - 系统监控脚本

# 配置
INTERVAL=5
LOG_FILE="/var/log/system_monitor.log"
CPU_THRESHOLD=80
MEMORY_THRESHOLD=80
DISK_THRESHOLD=90

log_message() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" | tee -a "$LOG_FILE"
}

get_cpu_usage() {
    top -bn1 | grep "Cpu(s)" | awk '{print $2}' | sed 's/%us,//'
}

get_memory_usage() {
    free | awk 'NR==2{printf "%.0f", $3*100/$2}'
}

get_disk_usage() {
    df / | awk 'NR==2{print $5}' | sed 's/%//'
}

check_processes() {
    local high_cpu_procs=()
    
    # 查找高CPU使用率进程
    while read -r pid cpu command; do
        if (( $(echo "$cpu > $CPU_THRESHOLD" | bc -l) )); then
            high_cpu_procs+=("PID:$pid CPU:${cpu}% CMD:$command")
        fi
    done < <(ps aux --no-headers | awk '{print $2, $3, $11}' | sort -k2 -nr | head -10)
    
    if [[ ${#high_cpu_procs[@]} -gt 0 ]]; then
        log_message "高CPU进程:"
        for proc in "${high_cpu_procs[@]}"; do
            log_message "  $proc"
        done
    fi
}

send_alert() {
    local message="$1"
    log_message "ALERT: $message"
    
    # 这里可以添加邮件或其他通知方式
    # echo "$message" | mail -s "系统告警" admin@example.com
}

monitor_loop() {
    log_message "开始系统监控 (间隔: ${INTERVAL}秒)"
    
    while true; do
        local cpu_usage=$(get_cpu_usage)
        local memory_usage=$(get_memory_usage)
        local disk_usage=$(get_disk_usage)
        
        # 记录当前状态
        log_message "CPU: ${cpu_usage}% | 内存: ${memory_usage}% | 磁盘: ${disk_usage}%"
        
        # 检查阈值
        if (( $(echo "$cpu_usage > $CPU_THRESHOLD" | bc -l) )); then
            send_alert "CPU使用率过高: ${cpu_usage}%"
            check_processes
        fi
        
        if [[ $memory_usage -gt $MEMORY_THRESHOLD ]]; then
            send_alert "内存使用率过高: ${memory_usage}%"
        fi
        
        if [[ $disk_usage -gt $DISK_THRESHOLD ]]; then
            send_alert "磁盘使用率过高: ${disk_usage}%"
        fi
        
        sleep $INTERVAL
    done
}

# 信号处理
cleanup() {
    log_message "监控程序退出"
    exit 0
}

trap cleanup SIGINT SIGTERM

# 主程序
case "${1:-monitor}" in
    monitor)
        monitor_loop
        ;;
    status)
        echo "CPU: $(get_cpu_usage)%"
        echo "内存: $(get_memory_usage)%"
        echo "磁盘: $(get_disk_usage)%"
        ;;
    *)
        echo "用法: $0 [monitor|status]"
        exit 1
        ;;
esac
```

### 练习3：日志分析工具
```bash
#!/bin/bash
# log_analyzer.sh - 日志分析工具

analyze_access_log() {
    local log_file="$1"
    local output_dir="$2"
    
    echo "分析访问日志: $log_file"
    
    # 创建输出目录
    mkdir -p "$output_dir"
    
    # 分析IP访问频率
    echo "=== TOP 10 访问IP ===" > "$output_dir/top_ips.txt"
    awk '{print $1}' "$log_file" | sort | uniq -c | sort -nr | head -10 >> "$output_dir/top_ips.txt"
    
    # 分析访问的URL
    echo "=== TOP 10 访问URL ===" > "$output_dir/top_urls.txt"
    awk '{print $7}' "$log_file" | sort | uniq -c | sort -nr | head -10 >> "$output_dir/top_urls.txt"
    
    # 分析HTTP状态码
    echo "=== HTTP状态码统计 ===" > "$output_dir/status_codes.txt"
    awk '{print $9}' "$log_file" | sort | uniq -c | sort -nr >> "$output_dir/status_codes.txt"
    
    # 分析用户代理
    echo "=== TOP 10 用户代理 ===" > "$output_dir/user_agents.txt"
    awk -F'"' '{print $6}' "$log_file" | sort | uniq -c | sort -nr | head -10 >> "$output_dir/user_agents.txt"
    
    # 按小时统计访问量
    echo "=== 按小时访问量统计 ===" > "$output_dir/hourly_stats.txt"
    awk '{print $4}' "$log_file" | cut -d: -f2 | sort | uniq -c >> "$output_dir/hourly_stats.txt"
    
    echo "分析完成，结果保存在: $output_dir"
}

# 主程序
if [[ $# -ne 2 ]]; then
    echo "用法: $0 <日志文件> <输出目录>"
    exit 1
fi

log_file="$1"
output_dir="$2"

if [[ ! -f "$log_file" ]]; then
    echo "错误: 日志文件不存在 - $log_file"
    exit 1
fi

analyze_access_log "$log_file" "$output_dir"
```

## 性能优化技巧

1. **避免在循环中调用外部命令**：尽量使用shell内置功能
2. **使用数组存储数据**：减少重复的文件读取
3. **合理使用并行处理**：但要控制并发数量
4. **优化正则表达式**：使用更精确的模式匹配
5. **及时释放资源**：关闭不需要的文件描述符