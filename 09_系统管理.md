# 系统管理脚本

## 1. 系统信息收集

### 基本系统信息
```bash
#!/bin/bash

# 获取系统基本信息
get_system_info() {
    echo "=== 系统基本信息 ==="
    echo "主机名: $(hostname)"
    echo "操作系统: $(uname -s)"
    echo "内核版本: $(uname -r)"
    echo "架构: $(uname -m)"
    echo "发行版: $(lsb_release -d 2>/dev/null | cut -f2 || cat /etc/os-release | grep PRETTY_NAME | cut -d'"' -f2)"
    echo "启动时间: $(uptime -s 2>/dev/null || uptime | awk '{print $3,$4}' | sed 's/,//')"
    echo "运行时间: $(uptime | awk -F'up ' '{print $2}' | awk -F',' '{print $1}')"
    echo "当前用户: $(whoami)"
    echo "用户ID: $(id -u)"
    echo "组ID: $(id -g)"
}

# 获取硬件信息
get_hardware_info() {
    echo "=== 硬件信息 ==="
    
    # CPU信息
    if [[ -f /proc/cpuinfo ]]; then
        local cpu_model=$(grep "model name" /proc/cpuinfo | head -1 | cut -d: -f2 | xargs)
        local cpu_cores=$(grep -c "^processor" /proc/cpuinfo)
        local cpu_freq=$(grep "cpu MHz" /proc/cpuinfo | head -1 | cut -d: -f2 | xargs)
        echo "CPU型号: $cpu_model"
        echo "CPU核心数: $cpu_cores"
        echo "CPU频率: ${cpu_freq} MHz"
    else
        echo "CPU信息: $(sysctl -n machdep.cpu.brand_string 2>/dev/null || echo "无法获取")"
    fi
    
    # 内存信息
    if [[ -f /proc/meminfo ]]; then
        local total_mem=$(grep "MemTotal" /proc/meminfo | awk '{print $2}')
        local available_mem=$(grep "MemAvailable" /proc/meminfo | awk '{print $2}')
        echo "总内存: $((total_mem / 1024)) MB"
        echo "可用内存: $((available_mem / 1024)) MB"
    else
        echo "内存信息: $(vm_stat 2>/dev/null | head -5 || echo "无法获取")"
    fi
    
    # 磁盘信息
    echo "磁盘使用情况:"
    df -h | grep -E "^/dev" | while read filesystem size used avail percent mount; do
        echo "  $mount: $used/$size ($percent)"
    done
}

# 获取网络信息
get_network_info() {
    echo "=== 网络信息 ==="
    
    # 网络接口
    if command -v ip >/dev/null; then
        echo "网络接口:"
        ip addr show | grep -E "^[0-9]+" | while read line; do
            local interface=$(echo "$line" | awk '{print $2}' | sed 's/://')
            local status=$(echo "$line" | grep -o "state [A-Z]*" | cut -d' ' -f2)
            echo "  $interface: $status"
        done
        
        # IP地址
        echo "IP地址:"
        ip addr show | grep "inet " | grep -v "127.0.0.1" | while read line; do
            local ip=$(echo "$line" | awk '{print $2}' | cut -d'/' -f1)
            local interface=$(ip addr show | grep -B2 "$line" | grep "^[0-9]" | awk '{print $2}' | sed 's/://')
            echo "  $interface: $ip"
        done
    else
        echo "网络接口:"
        ifconfig | grep -E "^[a-z]" | while read line; do
            local interface=$(echo "$line" | awk '{print $1}' | sed 's/://')
            echo "  $interface"
        done
    fi
    
    # 路由信息
    echo "默认网关:"
    if command -v ip >/dev/null; then
        ip route | grep default | awk '{print $3}'
    else
        route -n | grep "^0.0.0.0" | awk '{print $2}'
    fi
    
    # DNS服务器
    echo "DNS服务器:"
    if [[ -f /etc/resolv.conf ]]; then
        grep "nameserver" /etc/resolv.conf | awk '{print "  " $2}'
    fi
}
```

### 系统性能监控
```bash
#!/bin/bash

# CPU使用率监控
monitor_cpu() {
    local interval="${1:-5}"
    local count="${2:-12}"
    
    echo "=== CPU使用率监控 (间隔: ${interval}秒, 次数: $count) ==="
    
    for ((i=1; i<=count; i++)); do
        local timestamp=$(date '+%H:%M:%S')
        
        if command -v top >/dev/null; then
            local cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | sed 's/%us,//')
            echo "$timestamp - CPU使用率: ${cpu_usage}%"
        elif command -v iostat >/dev/null; then
            local cpu_usage=$(iostat -c 1 1 | tail -1 | awk '{print 100-$6}')
            echo "$timestamp - CPU使用率: ${cpu_usage}%"
        else
            echo "$timestamp - 无法获取CPU使用率"
        fi
        
        sleep "$interval"
    done
}

# 内存使用率监控
monitor_memory() {
    local interval="${1:-5}"
    local count="${2:-12}"
    
    echo "=== 内存使用率监控 (间隔: ${interval}秒, 次数: $count) ==="
    
    for ((i=1; i<=count; i++)); do
        local timestamp=$(date '+%H:%M:%S')
        
        if [[ -f /proc/meminfo ]]; then
            local total=$(grep "MemTotal" /proc/meminfo | awk '{print $2}')
            local available=$(grep "MemAvailable" /proc/meminfo | awk '{print $2}')
            local used=$((total - available))
            local usage=$((used * 100 / total))
            echo "$timestamp - 内存使用率: ${usage}% (${used}KB/${total}KB)"
        else
            echo "$timestamp - 无法获取内存使用率"
        fi
        
        sleep "$interval"
    done
}

# 磁盘I/O监控
monitor_disk_io() {
    local interval="${1:-5}"
    local count="${2:-12}"
    
    echo "=== 磁盘I/O监控 (间隔: ${interval}秒, 次数: $count) ==="
    
    if command -v iostat >/dev/null; then
        iostat -d "$interval" "$count"
    elif [[ -f /proc/diskstats ]]; then
        for ((i=1; i<=count; i++)); do
            local timestamp=$(date '+%H:%M:%S')
            echo "$timestamp - 磁盘统计:"
            awk '$4 ~ /^(sd|hd|vd|nvme)/ {printf "  %s: 读取 %s 写入 %s\n", $3, $6, $10}' /proc/diskstats
            sleep "$interval"
        done
    else
        echo "无法获取磁盘I/O信息"
    fi
}

# 网络流量监控
monitor_network() {
    local interface="${1:-eth0}"
    local interval="${2:-5}"
    local count="${3:-12}"
    
    echo "=== 网络流量监控 - $interface (间隔: ${interval}秒, 次数: $count) ==="
    
    if [[ -f /proc/net/dev ]]; then
        local prev_rx=0
        local prev_tx=0
        
        for ((i=1; i<=count; i++)); do
            local timestamp=$(date '+%H:%M:%S')
            
            if grep -q "$interface" /proc/net/dev; then
                local stats=$(grep "$interface" /proc/net/dev | awk '{print $2, $10}')
                local rx=$(echo "$stats" | awk '{print $1}')
                local tx=$(echo "$stats" | awk '{print $2}')
                
                if [[ $i -gt 1 ]]; then
                    local rx_rate=$(( (rx - prev_rx) / interval ))
                    local tx_rate=$(( (tx - prev_tx) / interval ))
                    echo "$timestamp - 接收: ${rx_rate} bytes/s, 发送: ${tx_rate} bytes/s"
                fi
                
                prev_rx=$rx
                prev_tx=$tx
            else
                echo "$timestamp - 接口 $interface 不存在"
            fi
            
            sleep "$interval"
        done
    else
        echo "无法获取网络流量信息"
    fi
}
```

## 2. 进程管理

### 进程监控和管理
```bash
#!/bin/bash

# 查找进程
find_process() {
    local pattern="$1"
    local show_details="${2:-false}"
    
    echo "=== 查找进程: $pattern ==="
    
    if [[ "$show_details" == "true" ]]; then
        ps aux | grep -E "$pattern" | grep -v grep
    else
        pgrep -f "$pattern"
    fi
}

# 杀死进程
kill_process() {
    local pattern="$1"
    local signal="${2:-TERM}"
    local force="${3:-false}"
    
    local pids=$(pgrep -f "$pattern")
    
    if [[ -z "$pids" ]]; then
        echo "未找到匹配的进程: $pattern"
        return 1
    fi
    
    echo "找到以下进程:"
    ps -p $pids -o pid,ppid,cmd
    
    if [[ "$force" != "true" ]]; then
        read -p "确认杀死这些进程? (y/N): " confirm
        if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
            echo "操作已取消"
            return 0
        fi
    fi
    
    for pid in $pids; do
        if kill -"$signal" "$pid" 2>/dev/null; then
            echo "已发送 $signal 信号给进程 $pid"
        else
            echo "无法杀死进程 $pid"
        fi
    done
}

# 进程资源使用统计
process_stats() {
    local pattern="$1"
    local sort_by="${2:-cpu}"
    
    echo "=== 进程资源统计: $pattern ==="
    
    case "$sort_by" in
        cpu)
            ps aux | grep -E "$pattern" | grep -v grep | sort -k3 -nr
            ;;
        memory)
            ps aux | grep -E "$pattern" | grep -v grep | sort -k4 -nr
            ;;
        time)
            ps aux | grep -E "$pattern" | grep -v grep | sort -k10 -nr
            ;;
        *)
            ps aux | grep -E "$pattern" | grep -v grep
            ;;
    esac
}

# 进程树显示
show_process_tree() {
    local pid="${1:-1}"
    
    echo "=== 进程树 (从PID $pid 开始) ==="
    
    if command -v pstree >/dev/null; then
        pstree -p "$pid"
    else
        ps --forest -o pid,ppid,cmd -g "$pid"
    fi
}

# 监控特定进程
monitor_process() {
    local pattern="$1"
    local interval="${2:-5}"
    local duration="${3:-60}"
    
    echo "=== 监控进程: $pattern (间隔: ${interval}秒, 持续: ${duration}秒) ==="
    
    local end_time=$(($(date +%s) + duration))
    
    while [[ $(date +%s) -lt $end_time ]]; do
        local timestamp=$(date '+%H:%M:%S')
        local pids=$(pgrep -f "$pattern")
        
        if [[ -n "$pids" ]]; then
            echo "$timestamp - 进程运行中:"
            ps -p $pids -o pid,ppid,%cpu,%mem,cmd --no-headers | while read line; do
                echo "  $line"
            done
        else
            echo "$timestamp - 进程未运行"
        fi
        
        echo
        sleep "$interval"
    done
}
```

### 服务管理
```bash
#!/bin/bash

# 检查服务状态
check_service() {
    local service="$1"
    
    if command -v systemctl >/dev/null; then
        local status=$(systemctl is-active "$service" 2>/dev/null)
        local enabled=$(systemctl is-enabled "$service" 2>/dev/null)
        echo "服务 $service:"
        echo "  状态: $status"
        echo "  开机启动: $enabled"
    elif command -v service >/dev/null; then
        if service "$service" status >/dev/null 2>&1; then
            echo "服务 $service: 运行中"
        else
            echo "服务 $service: 已停止"
        fi
    else
        echo "无法检查服务状态"
    fi
}

# 管理服务
manage_service() {
    local action="$1"
    local service="$2"
    
    case "$action" in
        start)
            if command -v systemctl >/dev/null; then
                systemctl start "$service"
            else
                service "$service" start
            fi
            echo "启动服务: $service"
            ;;
        stop)
            if command -v systemctl >/dev/null; then
                systemctl stop "$service"
            else
                service "$service" stop
            fi
            echo "停止服务: $service"
            ;;
        restart)
            if command -v systemctl >/dev/null; then
                systemctl restart "$service"
            else
                service "$service" restart
            fi
            echo "重启服务: $service"
            ;;
        enable)
            if command -v systemctl >/dev/null; then
                systemctl enable "$service"
                echo "启用开机启动: $service"
            else
                echo "当前系统不支持enable操作"
            fi
            ;;
        disable)
            if command -v systemctl >/dev/null; then
                systemctl disable "$service"
                echo "禁用开机启动: $service"
            else
                echo "当前系统不支持disable操作"
            fi
            ;;
        status)
            check_service "$service"
            ;;
        *)
            echo "用法: manage_service [start|stop|restart|enable|disable|status] <服务名>"
            ;;
    esac
}

# 批量服务管理
batch_service_management() {
    local action="$1"
    shift
    local services=("$@")
    
    echo "=== 批量服务管理: $action ==="
    
    for service in "${services[@]}"; do
        echo "处理服务: $service"
        manage_service "$action" "$service"
        echo
    done
}

# 服务依赖检查
check_service_dependencies() {
    local service="$1"
    
    if command -v systemctl >/dev/null; then
        echo "=== 服务依赖: $service ==="
        echo "依赖的服务:"
        systemctl list-dependencies "$service" --plain | grep -v "$service"
        echo
        echo "被依赖的服务:"
        systemctl list-dependencies "$service" --reverse --plain | grep -v "$service"
    else
        echo "当前系统不支持依赖检查"
    fi
}
```

## 3. 用户管理

### 用户账户管理
```bash
#!/bin/bash

# 创建用户
create_user() {
    local username="$1"
    local password="$2"
    local home_dir="$3"
    local shell="${4:-/bin/bash}"
    local groups="$5"
    
    if [[ -z "$username" ]]; then
        echo "错误: 用户名不能为空"
        return 1
    fi
    
    # 检查用户是否已存在
    if id "$username" >/dev/null 2>&1; then
        echo "错误: 用户 $username 已存在"
        return 1
    fi
    
    # 构建useradd命令
    local cmd="useradd"
    
    if [[ -n "$home_dir" ]]; then
        cmd+=" -d $home_dir"
    fi
    
    cmd+=" -s $shell"
    
    if [[ -n "$groups" ]]; then
        cmd+=" -G $groups"
    fi
    
    cmd+=" $username"
    
    # 执行命令
    if eval "$cmd"; then
        echo "用户 $username 创建成功"
        
        # 设置密码
        if [[ -n "$password" ]]; then
            echo "$username:$password" | chpasswd
            echo "密码设置成功"
        fi
        
        return 0
    else
        echo "错误: 创建用户失败"
        return 1
    fi
}

# 删除用户
delete_user() {
    local username="$1"
    local remove_home="${2:-false}"
    
    if [[ -z "$username" ]]; then
        echo "错误: 用户名不能为空"
        return 1
    fi
    
    # 检查用户是否存在
    if ! id "$username" >/dev/null 2>&1; then
        echo "错误: 用户 $username 不存在"
        return 1
    fi
    
    # 确认删除
    read -p "确认删除用户 $username? (y/N): " confirm
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        echo "操作已取消"
        return 0
    fi
    
    # 构建userdel命令
    local cmd="userdel"
    if [[ "$remove_home" == "true" ]]; then
        cmd+=" -r"
    fi
    cmd+=" $username"
    
    # 执行命令
    if eval "$cmd"; then
        echo "用户 $username 删除成功"
        return 0
    else
        echo "错误: 删除用户失败"
        return 1
    fi
}

# 修改用户信息
modify_user() {
    local username="$1"
    local field="$2"
    local value="$3"
    
    if [[ -z "$username" ]]; then
        echo "错误: 用户名不能为空"
        return 1
    fi
    
    # 检查用户是否存在
    if ! id "$username" >/dev/null 2>&1; then
        echo "错误: 用户 $username 不存在"
        return 1
    fi
    
    case "$field" in
        password)
            echo "$username:$value" | chpasswd
            echo "用户 $username 密码修改成功"
            ;;
        shell)
            usermod -s "$value" "$username"
            echo "用户 $username shell修改为 $value"
            ;;
        home)
            usermod -d "$value" "$username"
            echo "用户 $username 主目录修改为 $value"
            ;;
        groups)
            usermod -G "$value" "$username"
            echo "用户 $username 组修改为 $value"
            ;;
        comment)
            usermod -c "$value" "$username"
            echo "用户 $username 注释修改为 $value"
            ;;
        *)
            echo "不支持的字段: $field"
            echo "支持的字段: password, shell, home, groups, comment"
            return 1
            ;;
    esac
}

# 用户信息查询
query_user() {
    local username="$1"
    
    if [[ -n "$username" ]]; then
        # 查询特定用户
        if id "$username" >/dev/null 2>&1; then
            echo "=== 用户信息: $username ==="
            id "$username"
            echo "主目录: $(getent passwd "$username" | cut -d: -f6)"
            echo "Shell: $(getent passwd "$username" | cut -d: -f7)"
            echo "最后登录: $(last -n 1 "$username" | head -1)"
            echo "用户组:"
            groups "$username"
        else
            echo "用户 $username 不存在"
        fi
    else
        # 列出所有用户
        echo "=== 系统用户列表 ==="
        getent passwd | while IFS=: read username password uid gid comment home shell; do
            if [[ $uid -ge 1000 ]]; then
                echo "$username (UID: $uid, 主目录: $home, Shell: $shell)"
            fi
        done
    fi
}

# 用户登录监控
monitor_user_logins() {
    local duration="${1:-3600}"  # 默认监控1小时
    local log_file="${2:-/var/log/auth.log}"
    
    echo "=== 用户登录监控 (持续 $duration 秒) ==="
    
    local end_time=$(($(date +%s) + duration))
    
    if [[ -f "$log_file" ]]; then
        tail -f "$log_file" | while read line; do
            if [[ $(date +%s) -gt $end_time ]]; then
                break
            fi
            
            if echo "$line" | grep -q "session opened"; then
                local user=$(echo "$line" | grep -o "user [a-zA-Z0-9_]*" | cut -d' ' -f2)
                local timestamp=$(echo "$line" | awk '{print $1, $2, $3}')
                echo "$timestamp - 用户 $user 登录"
            elif echo "$line" | grep -q "session closed"; then
                local user=$(echo "$line" | grep -o "user [a-zA-Z0-9_]*" | cut -d' ' -f2)
                local timestamp=$(echo "$line" | awk '{print $1, $2, $3}')
                echo "$timestamp - 用户 $user 注销"
            fi
        done
    else
        echo "日志文件不存在: $log_file"
    fi
}
```

## 4. 系统维护

### 系统清理
```bash
#!/bin/bash

# 清理临时文件
cleanup_temp_files() {
    local temp_dirs=("/tmp" "/var/tmp" "/var/cache")
    local days="${1:-7}"
    local dry_run="${2:-false}"
    
    echo "=== 清理临时文件 (${days}天前的文件) ==="
    
    for dir in "${temp_dirs[@]}"; do
        if [[ -d "$dir" ]]; then
            echo "清理目录: $dir"
            
            if [[ "$dry_run" == "true" ]]; then
                find "$dir" -type f -mtime +$days -ls
            else
                local count=$(find "$dir" -type f -mtime +$days | wc -l)
                find "$dir" -type f -mtime +$days -delete
                echo "  删除了 $count 个文件"
            fi
        fi
    done
}

# 清理日志文件
cleanup_log_files() {
    local log_dirs=("/var/log")
    local size_limit="${1:-100M}"
    local dry_run="${2:-false}"
    
    echo "=== 清理大日志文件 (大于 $size_limit) ==="
    
    for dir in "${log_dirs[@]}"; do
        if [[ -d "$dir" ]]; then
            echo "检查目录: $dir"
            
            find "$dir" -name "*.log" -size "+$size_limit" | while read logfile; do
                local size=$(du -h "$logfile" | cut -f1)
                echo "  发现大文件: $logfile ($size)"
                
                if [[ "$dry_run" != "true" ]]; then
                    # 压缩日志文件
                    gzip "$logfile"
                    echo "    已压缩: ${logfile}.gz"
                fi
            done
        fi
    done
}

# 清理包缓存
cleanup_package_cache() {
    local dry_run="${1:-false}"
    
    echo "=== 清理包缓存 ==="
    
    if command -v apt-get >/dev/null; then
        if [[ "$dry_run" == "true" ]]; then
            echo "将执行: apt-get clean"
            echo "将执行: apt-get autoremove"
        else
            apt-get clean
            apt-get autoremove -y
            echo "APT缓存清理完成"
        fi
    elif command -v yum >/dev/null; then
        if [[ "$dry_run" == "true" ]]; then
            echo "将执行: yum clean all"
        else
            yum clean all
            echo "YUM缓存清理完成"
        fi
    elif command -v dnf >/dev/null; then
        if [[ "$dry_run" == "true" ]]; then
            echo "将执行: dnf clean all"
        else
            dnf clean all
            echo "DNF缓存清理完成"
        fi
    else
        echo "未找到支持的包管理器"
    fi
}

# 磁盘空间分析
analyze_disk_usage() {
    local directory="${1:-/}"
    local depth="${2:-2}"
    
    echo "=== 磁盘使用分析: $directory ==="
    
    # 总体使用情况
    echo "总体磁盘使用:"
    df -h "$directory"
    echo
    
    # 目录使用情况
    echo "目录使用情况 (前10个最大目录):"
    du -h --max-depth="$depth" "$directory" 2>/dev/null | sort -hr | head -10
    echo
    
    # 大文件查找
    echo "大文件 (大于100MB):"
    find "$directory" -type f -size +100M -exec ls -lh {} \; 2>/dev/null | head -10
}

# 系统健康检查
system_health_check() {
    local output_file="${1:-system_health.txt}"
    
    {
        echo "系统健康检查报告"
        echo "生成时间: $(date)"
        echo "========================================"
        echo
        
        # 系统负载
        echo "=== 系统负载 ==="
        uptime
        echo
        
        # 内存使用
        echo "=== 内存使用 ==="
        free -h
        echo
        
        # 磁盘使用
        echo "=== 磁盘使用 ==="
        df -h
        echo
        
        # 网络连接
        echo "=== 网络连接 ==="
        netstat -tuln | head -20
        echo
        
        # 进程统计
        echo "=== 进程统计 ==="
        echo "总进程数: $(ps aux | wc -l)"
        echo "运行中进程: $(ps aux | awk '$8 ~ /^R/ {count++} END {print count+0}')"
        echo "休眠进程: $(ps aux | awk '$8 ~ /^S/ {count++} END {print count+0}')"
        echo
        
        # 高CPU进程
        echo "=== CPU使用率最高的进程 ==="
        ps aux --no-headers | sort -k3 -nr | head -5
        echo
        
        # 高内存进程
        echo "=== 内存使用率最高的进程 ==="
        ps aux --no-headers | sort -k4 -nr | head -5
        echo
        
        # 系统错误
        echo "=== 最近的系统错误 ==="
        if [[ -f /var/log/syslog ]]; then
            grep -i error /var/log/syslog | tail -5
        elif [[ -f /var/log/messages ]]; then
            grep -i error /var/log/messages | tail -5
        else
            echo "未找到系统日志文件"
        fi
        
    } | tee "$output_file"
    
    echo
    echo "健康检查完成，报告保存在: $output_file"
}
```

### 备份和恢复
```bash
#!/bin/bash

# 系统配置备份
backup_system_config() {
    local backup_dir="${1:-/backup/system-$(date +%Y%m%d)}"
    local config_dirs=("/etc" "/home" "/var/www" "/opt")
    
    echo "=== 系统配置备份到: $backup_dir ==="
    
    mkdir -p "$backup_dir"
    
    for dir in "${config_dirs[@]}"; do
        if [[ -d "$dir" ]]; then
            local backup_name="$(basename "$dir")-$(date +%Y%m%d-%H%M%S).tar.gz"
            echo "备份 $dir 到 $backup_name"
            
            tar -czf "$backup_dir/$backup_name" "$dir" 2>/dev/null
            
            if [[ $? -eq 0 ]]; then
                echo "  备份成功: $backup_name"
            else
                echo "  备份失败: $dir"
            fi
        fi
    done
    
    # 创建备份清单
    {
        echo "系统配置备份清单"
        echo "备份时间: $(date)"
        echo "备份目录: $backup_dir"
        echo "========================================"
        ls -la "$backup_dir"
    } > "$backup_dir/backup_manifest.txt"
    
    echo "备份完成，清单保存在: $backup_dir/backup_manifest.txt"
}

# 数据库备份
backup_database() {
    local db_type="$1"
    local db_name="$2"
    local backup_dir="${3:-/backup/database}"
    local username="$4"
    local password="$5"
    
    mkdir -p "$backup_dir"
    local backup_file="$backup_dir/${db_name}-$(date +%Y%m%d-%H%M%S).sql"
    
    case "$db_type" in
        mysql)
            if [[ -n "$username" && -n "$password" ]]; then
                mysqldump -u "$username" -p"$password" "$db_name" > "$backup_file"
            else
                mysqldump "$db_name" > "$backup_file"
            fi
            ;;
        postgresql)
            if [[ -n "$username" ]]; then
                pg_dump -U "$username" "$db_name" > "$backup_file"
            else
                pg_dump "$db_name" > "$backup_file"
            fi
            ;;
        *)
            echo "不支持的数据库类型: $db_type"
            return 1
            ;;
    esac
    
    if [[ $? -eq 0 ]]; then
        echo "数据库备份成功: $backup_file"
        gzip "$backup_file"
        echo "备份已压缩: ${backup_file}.gz"
    else
        echo "数据库备份失败"
        return 1
    fi
}

# 增量备份
incremental_backup() {
    local source_dir="$1"
    local backup_base="$2"
    local exclude_file="$3"
    
    local backup_name="incremental-$(date +%Y%m%d-%H%M%S)"
    local backup_dir="$backup_base/$backup_name"
    local latest_link="$backup_base/latest"
    
    mkdir -p "$backup_base"
    
    echo "=== 增量备份: $source_dir ==="
    echo "备份到: $backup_dir"
    
    # 构建rsync命令
    local rsync_cmd="rsync -av --delete"
    
    if [[ -n "$exclude_file" && -f "$exclude_file" ]]; then
        rsync_cmd+=" --exclude-from=$exclude_file"
    fi
    
    # 如果存在最新备份，使用硬链接
    if [[ -d "$latest_link" ]]; then
        rsync_cmd+=" --link-dest=$latest_link"
    fi
    
    rsync_cmd+=" $source_dir/ $backup_dir/"
    
    # 执行备份
    if eval "$rsync_cmd"; then
        # 更新最新备份链接
        rm -f "$latest_link"
        ln -s "$backup_name" "$latest_link"
        
        echo "增量备份完成: $backup_dir"
        
        # 记录备份信息
        {
            echo "增量备份信息"
            echo "备份时间: $(date)"
            echo "源目录: $source_dir"
            echo "备份目录: $backup_dir"
            echo "文件统计:"
            find "$backup_dir" -type f | wc -l
            echo "总大小:"
            du -sh "$backup_dir"
        } > "$backup_dir/backup_info.txt"
        
        return 0
    else
        echo "增量备份失败"
        return 1
    fi
}

# 清理旧备份
cleanup_old_backups() {
    local backup_dir="$1"
    local keep_days="${2:-30}"
    local dry_run="${3:-false}"
    
    echo "=== 清理旧备份 (保留 $keep_days 天) ==="
    
    if [[ ! -d "$backup_dir" ]]; then
        echo "备份目录不存在: $backup_dir"
        return 1
    fi
    
    local old_backups=$(find "$backup_dir" -maxdepth 1 -type d -mtime +$keep_days -name "*-[0-9]*")
    
    if [[ -z "$old_backups" ]]; then
        echo "没有需要清理的旧备份"
        return 0
    fi
    
    echo "发现以下旧备份:"
    echo "$old_backups"
    
    if [[ "$dry_run" == "true" ]]; then
        echo "模拟运行，不会实际删除"
        return 0
    fi
    
    read -p "确认删除这些备份? (y/N): " confirm
    if [[ "$confirm" == "y" || "$confirm" == "Y" ]]; then
        echo "$old_backups" | while read backup; do
            rm -rf "$backup"
            echo "已删除: $backup"
        done
        echo "旧备份清理完成"
    else
        echo "操作已取消"
    fi
}
```

## 5. 实践练习

### 练习1：系统监控脚本
```bash
#!/bin/bash
# system_monitor.sh - 综合系统监控脚本

# 配置参数
CONFIG_FILE="/etc/system_monitor.conf"
LOG_FILE="/var/log/system_monitor.log"
ALERT_EMAIL="admin@example.com"
CHECK_INTERVAL=60

# 阈值配置
CPU_THRESHOLD=80
MEMORY_THRESHOLD=85
DISK_THRESHOLD=90
LOAD_THRESHOLD=5.0

# 日志函数
log_message() {
    local level="$1"
    shift
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [$level] $*" | tee -a "$LOG_FILE"
}

# 发送告警
send_alert() {
    local subject="$1"
    local message="$2"
    
    log_message "ALERT" "$subject"
    
    # 发送邮件告警
    if command -v mail >/dev/null; then
        echo "$message" | mail -s "$subject" "$ALERT_EMAIL"
    fi
    
    # 发送系统通知
    if command -v notify-send >/dev/null; then
        notify-send "系统告警" "$subject"
    fi
}

# CPU监控
check_cpu() {
    local cpu_usage
    
    if command -v top >/dev/null; then
        cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | sed 's/%us,//')
    else
        cpu_usage=0
    fi
    
    log_message "INFO" "CPU使用率: ${cpu_usage}%"
    
    if (( $(echo "$cpu_usage > $CPU_THRESHOLD" | bc -l) )); then
        send_alert "CPU使用率告警" "CPU使用率 ${cpu_usage}% 超过阈值 ${CPU_THRESHOLD}%"
        
        # 记录高CPU进程
        log_message "INFO" "高CPU进程:"
        ps aux --no-headers | sort -k3 -nr | head -5 | while read line; do
            log_message "INFO" "  $line"
        done
    fi
}

# 内存监控
check_memory() {
    local memory_usage
    
    if [[ -f /proc/meminfo ]]; then
        local total=$(grep "MemTotal" /proc/meminfo | awk '{print $2}')
        local available=$(grep "MemAvailable" /proc/meminfo | awk '{print $2}')
        local used=$((total - available))
        memory_usage=$((used * 100 / total))
    else
        memory_usage=0
    fi
    
    log_message "INFO" "内存使用率: ${memory_usage}%"
    
    if [[ $memory_usage -gt $MEMORY_THRESHOLD ]]; then
        send_alert "内存使用率告警" "内存使用率 ${memory_usage}% 超过阈值 ${MEMORY_THRESHOLD}%"
        
        # 记录高内存进程
        log_message "INFO" "高内存进程:"
        ps aux --no-headers | sort -k4 -nr | head -5 | while read line; do
            log_message "INFO" "  $line"
        done
    fi
}

# 磁盘监控
check_disk() {
    df -h | grep -E "^/dev" | while read filesystem size used avail percent mount; do
        local usage=$(echo "$percent" | sed 's/%//')
        
        log_message "INFO" "磁盘使用率 $mount: ${usage}%"
        
        if [[ $usage -gt $DISK_THRESHOLD ]]; then
            send_alert "磁盘空间告警" "磁盘 $mount 使用率 ${usage}% 超过阈值 ${DISK_THRESHOLD}%"
            
            # 记录大文件
            log_message "INFO" "大文件 (>100MB) in $mount:"
            find "$mount" -type f -size +100M -exec ls -lh {} \; 2>/dev/null | head -5 | while read line; do
                log_message "INFO" "  $line"
            done
        fi
    done
}

# 系统负载监控
check_load() {
    local load_avg=$(uptime | awk -F'load average:' '{print $2}' | awk '{print $1}' | sed 's/,//')
    
    log_message "INFO" "系统负载: $load_avg"
    
    if (( $(echo "$load_avg > $LOAD_THRESHOLD" | bc -l) )); then
        send_alert "系统负载告警" "系统负载 $load_avg 超过阈值 $LOAD_THRESHOLD"
    fi
}

# 服务监控
check_services() {
    local services=("ssh" "nginx" "mysql" "postgresql")
    
    for service in "${services[@]}"; do
        if command -v systemctl >/dev/null; then
            local status=$(systemctl is-active "$service" 2>/dev/null)
            if [[ "$status" != "active" ]]; then
                send_alert "服务状态告警" "服务 $service 状态异常: $status"
            else
                log_message "INFO" "服务 $service: $status"
            fi
        fi
    done
}

# 网络监控
check_network() {
    # 检查网络连通性
    local test_hosts=("8.8.8.8" "google.com")
    
    for host in "${test_hosts[@]}"; do
        if ! ping -c 1 -W 5 "$host" >/dev/null 2>&1; then
            send_alert "网络连通性告警" "无法连接到 $host"
        else
            log_message "INFO" "网络连通性正常: $host"
        fi
    done
    
    # 检查网络接口
    if command -v ip >/dev/null; then
        ip link show | grep -E "^[0-9]+" | while read line; do
            local interface=$(echo "$line" | awk '{print $2}' | sed 's/://')
            local status=$(echo "$line" | grep -o "state [A-Z]*" | cut -d' ' -f2)
            
            if [[ "$status" == "DOWN" && "$interface" != "lo" ]]; then
                send_alert "网络接口告警" "网络接口 $interface 状态: $status"
            fi
        done
    fi
}

# 主监控循环
main_monitor() {
    log_message "INFO" "系统监控启动"
    
    while true; do
        log_message "INFO" "开始监控检查"
        
        check_cpu
        check_memory
        check_disk
        check_load
        check_services
        check_network
        
        log_message "INFO" "监控检查完成，等待 $CHECK_INTERVAL 秒"
        sleep "$CHECK_INTERVAL"
    done
}

# 生成监控报告
generate_report() {
    local report_file="${1:-system_monitor_report.txt}"
    local days="${2:-7}"
    
    {
        echo "系统监控报告"
        echo "报告时间: $(date)"
        echo "统计周期: 最近 $days 天"
        echo "========================================"
        echo
        
        echo "=== 告警统计 ==="
        grep "\[ALERT\]" "$LOG_FILE" | tail -50
        echo
        
        echo "=== CPU使用率趋势 ==="
        grep "CPU使用率" "$LOG_FILE" | tail -20
        echo
        
        echo "=== 内存使用率趋势 ==="
        grep "内存使用率" "$LOG_FILE" | tail -20
        echo
        
        echo "=== 磁盘使用率趋势 ==="
        grep "磁盘使用率" "$LOG_FILE" | tail -20
        echo
        
        echo "=== 系统负载趋势 ==="
        grep "系统负载" "$LOG_FILE" | tail -20
        
    } > "$report_file"
    
    echo "监控报告生成完成: $report_file"
}

# 主函数
main() {
    case "${1:-monitor}" in
        monitor)
            main_monitor
            ;;
        report)
            generate_report "$2" "$3"
            ;;
        check)
            log_message "INFO" "执行单次检查"
            check_cpu
            check_memory
            check_disk
            check_load
            check_services
            check_network
            ;;
        *)
            echo "用法: $0 [monitor|report|check]"
            echo "  monitor  - 启动持续监控"
            echo "  report   - 生成监控报告"
            echo "  check    - 执行单次检查"
            exit 1
            ;;
    esac
}

# 信号处理
cleanup() {
    log_message "INFO" "系统监控停止"
    exit 0
}

trap cleanup SIGINT SIGTERM

main "$@"
```

### 练习2：自动化部署脚本
```bash
#!/bin/bash
# auto_deploy.sh - 自动化部署脚本

# 配置参数
APP_NAME="myapp"
APP_USER="www-data"
APP_DIR="/var/www/$APP_NAME"
BACKUP_DIR="/backup/$APP_NAME"
LOG_FILE="/var/log/deploy.log"
GIT_REPO="https://github.com/user/myapp.git"
BRANCH="main"

# 服务配置
SERVICES=("nginx" "php-fpm" "mysql")
REQUIRED_PACKAGES=("git" "nginx" "php" "mysql-server")

# 日志函数
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" | tee -a "$LOG_FILE"
}

# 错误处理
error_exit() {
    log "ERROR: $1"
    exit 1
}

# 检查权限
check_permissions() {
    if [[ $EUID -ne 0 ]]; then
        error_exit "此脚本需要root权限运行"
    fi
}

# 检查依赖
check_dependencies() {
    log "检查系统依赖..."
    
    for package in "${REQUIRED_PACKAGES[@]}"; do
        if ! command -v "$package" >/dev/null; then
            log "安装缺失的包: $package"
            
            if command -v apt-get >/dev/null; then
                apt-get update && apt-get install -y "$package"
            elif command -v yum >/dev/null; then
                yum install -y "$package"
            else
                error_exit "无法安装 $package，请手动安装"
            fi
        else
            log "依赖检查通过: $package"
        fi
    done
}

# 创建用户
create_app_user() {
    if ! id "$APP_USER" >/dev/null 2>&1; then
        log "创建应用用户: $APP_USER"
        useradd -r -s /bin/bash -d "$APP_DIR" "$APP_USER"
    else
        log "应用用户已存在: $APP_USER"
    fi
}

# 备份当前版本
backup_current() {
    if [[ -d "$APP_DIR" ]]; then
        local backup_name="backup-$(date +%Y%m%d-%H%M%S)"
        local backup_path="$BACKUP_DIR/$backup_name"
        
        log "备份当前版本到: $backup_path"
        mkdir -p "$BACKUP_DIR"
        cp -r "$APP_DIR" "$backup_path"
        
        # 创建符号链接到最新备份
        ln -sfn "$backup_name" "$BACKUP_DIR/latest"
        
        log "备份完成"
    else
        log "没有现有版本需要备份"
    fi
}

# 部署应用
deploy_app() {
    log "开始部署应用..."
    
    # 创建应用目录
    mkdir -p "$APP_DIR"
    
    # 克隆或更新代码
    if [[ -d "$APP_DIR/.git" ]]; then
        log "更新现有代码库..."
        cd "$APP_DIR"
        git fetch origin
        git reset --hard "origin/$BRANCH"
    else
        log "克隆代码库..."
        git clone -b "$BRANCH" "$GIT_REPO" "$APP_DIR"
    fi
    
    # 设置权限
    chown -R "$APP_USER:$APP_USER" "$APP_DIR"
    chmod -R 755 "$APP_DIR"
    
    log "代码部署完成"
}

# 安装依赖
install_dependencies() {
    log "安装应用依赖..."
    
    cd "$APP_DIR"
    
    # PHP Composer依赖
    if [[ -f "composer.json" ]]; then
        if command -v composer >/dev/null; then
            sudo -u "$APP_USER" composer install --no-dev --optimize-autoloader
        else
            log "警告: composer未安装，跳过PHP依赖安装"
        fi
    fi
    
    # Node.js依赖
    if [[ -f "package.json" ]]; then
        if command -v npm >/dev/null; then
            sudo -u "$APP_USER" npm install --production
        else
            log "警告: npm未安装，跳过Node.js依赖安装"
        fi
    fi
    
    # Python依赖
    if [[ -f "requirements.txt" ]]; then
        if command -v pip >/dev/null; then
            pip install -r requirements.txt
        else
            log "警告: pip未安装，跳过Python依赖安装"
        fi
    fi
}

# 配置应用
configure_app() {
    log "配置应用..."
    
    cd "$APP_DIR"
    
    # 复制配置文件
    if [[ -f "config/app.conf.example" ]]; then
        cp "config/app.conf.example" "config/app.conf"
        log "配置文件已创建"
    fi
    
    # 设置环境变量
    if [[ -f ".env.example" ]]; then
        cp ".env.example" ".env"
        log "环境配置文件已创建"
    fi
    
    # 创建必要目录
    local dirs=("logs" "cache" "uploads" "tmp")
    for dir in "${dirs[@]}"; do
        if [[ ! -d "$dir" ]]; then
            mkdir -p "$dir"
            chown "$APP_USER:$APP_USER" "$dir"
            chmod 755 "$dir"
        fi
    done
}

# 数据库迁移
migrate_database() {
    log "执行数据库迁移..."
    
    cd "$APP_DIR"
    
    # Laravel迁移
    if [[ -f "artisan" ]]; then
        sudo -u "$APP_USER" php artisan migrate --force
    fi
    
    # Django迁移
    if [[ -f "manage.py" ]]; then
        sudo -u "$APP_USER" python manage.py migrate
    fi
    
    # 自定义SQL脚本
    if [[ -d "database/migrations" ]]; then
        for sql_file in database/migrations/*.sql; do
            if [[ -f "$sql_file" ]]; then
                mysql -u root < "$sql_file"
                log "执行SQL脚本: $sql_file"
            fi
        done
    fi
}

# 重启服务
restart_services() {
    log "重启相关服务..."
    
    for service in "${SERVICES[@]}"; do
        if systemctl is-active "$service" >/dev/null; then
            log "重启服务: $service"
            systemctl restart "$service"
            
            # 检查服务状态
            if systemctl is-active "$service" >/dev/null; then
                log "服务 $service 重启成功"
            else
                error_exit "服务 $service 重启失败"
            fi
        else
            log "警告: 服务 $service 未运行"
        fi
    done
}

# 健康检查
health_check() {
    log "执行健康检查..."
    
    # 检查HTTP响应
    local health_url="http://localhost/health"
    local max_attempts=30
    local attempt=1
    
    while [[ $attempt -le $max_attempts ]]; do
        if curl -s -f "$health_url" >/dev/null; then
            log "健康检查通过"
            return 0
        fi
        
        log "健康检查失败，重试 $attempt/$max_attempts"
        sleep 2
        ((attempt++))
    done
    
    error_exit "健康检查失败，部署可能有问题"
}

# 回滚部署
rollback() {
    local backup_name="${1:-latest}"
    local backup_path="$BACKUP_DIR/$backup_name"
    
    if [[ ! -d "$backup_path" ]]; then
        error_exit "备份不存在: $backup_path"
    fi
    
    log "回滚到备份: $backup_name"
    
    # 停止服务
    for service in "${SERVICES[@]}"; do
        systemctl stop "$service"
    done
    
    # 恢复备份
    rm -rf "$APP_DIR"
    cp -r "$backup_path" "$APP_DIR"
    chown -R "$APP_USER:$APP_USER" "$APP_DIR"
    
    # 重启服务
    restart_services
    
    log "回滚完成"
}

# 清理旧备份
cleanup_backups() {
    local keep_count="${1:-5}"
    
    log "清理旧备份，保留最新 $keep_count 个"
    
    cd "$BACKUP_DIR"
    ls -t | tail -n +$((keep_count + 1)) | while read backup; do
        if [[ -d "$backup" && "$backup" != "latest" ]]; then
            rm -rf "$backup"
            log "删除旧备份: $backup"
        fi
    done
}

# 主部署流程
deploy() {
    log "开始自动化部署 $APP_NAME"
    
    check_permissions
    check_dependencies
    create_app_user
    backup_current
    deploy_app
    install_dependencies
    configure_app
    migrate_database
    restart_services
    health_check
    cleanup_backups
    
    log "部署完成！"
}

# 主函数
main() {
    case "${1:-deploy}" in
        deploy)
            deploy
            ;;
        rollback)
            rollback "$2"
            ;;
        health)
            health_check
            ;;
        backup)
            backup_current
            ;;
        cleanup)
            cleanup_backups "$2"
            ;;
        *)
            echo "用法: $0 [deploy|rollback|health|backup|cleanup]"
            echo "  deploy           - 执行完整部署"
            echo "  rollback [name]  - 回滚到指定备份"
            echo "  health           - 执行健康检查"
            echo "  backup           - 备份当前版本"
            echo "  cleanup [count]  - 清理旧备份"
            exit 1
            ;;
    esac
}

main "$@"
```

## 最佳实践

1. **权限管理**：使用最小权限原则，避免不必要的root权限
2. **错误处理**：充分的错误检查和异常处理
3. **日志记录**：详细记录操作日志，便于问题排查
4. **配置管理**：将配置参数外部化，便于维护
5. **备份策略**：重要操作前先备份，支持快速回滚
6. **监控告警**：实时监控系统状态，及时发现问题
7. **文档化**：为脚本添加详细的使用说明和注释