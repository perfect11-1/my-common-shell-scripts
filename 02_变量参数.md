# 变量和参数详解

## 1. 变量作用域

### 局部变量
```bash
#!/bin/bash
function test_local() {
    local local_var="我是局部变量"
    global_var="我是全局变量"
    echo "函数内: $local_var"
}

test_local
echo "函数外: $global_var"
# echo "函数外: $local_var"  # 这行会报错，局部变量不可访问
```

### 环境变量
```bash
# 查看所有环境变量
env
printenv

# 常用环境变量
echo $HOME      # 用户主目录
echo $PATH      # 可执行文件路径
echo $USER      # 当前用户名
echo $PWD       # 当前工作目录
echo $SHELL     # 当前shell

# 设置环境变量
export MY_VAR="hello"
export PATH=$PATH:/new/path
```

## 2. 参数扩展

### 基本参数扩展
```bash
name="yang yi cheng"

echo ${#name} # 字符串长度：13（包含空格，一个空格算一个字符串）
echo ${name:2} # 截取字符串,从编号为2的字符开始截取到结尾：ng yi cheng
echo ${name:1:6} # 截取字符串,从编号为1的字符开始截取6个字符：ang yi
echo ${name: -5} #截取最后五个字符：cheng
```

### 参数替换
```bash
name="yang yi cheng"

# 删除匹配模式
echo ${name#*y} #从左边开始删除第一个匹配的字符串：ang yi cheng
echo ${name##*y} #从左边开始删除最后一个匹配的字符串：i cheng
echo ${name%n*} #从右边开始删除第一个匹配的字符串：yang yi che
echo ${name%%n*} #从右边开始删除最后一个匹配的字符串：ya

# 替换匹配模式
echo ${name/yi/YI} # 替换字符串：yang YI cheng
echo ${name//y/Y} # 全局替换字符串：yang YI cheng
```

### 默认值处理
```bash
username=${username:-zheng} # 如果变量未设置，使用默认值：zheng
echo $username  # 打印zheng
```

## 3. 命令行参数处理

### 基本参数处理
```bash
#!/bin/bash
# script.sh -u username -p password -h

while [[ $# -gt 0 ]]; do
    case $1 in
        -u|--username)
            USERNAME="$2"
            shift 2
            ;;
        -p|--password)
            PASSWORD="$2"
            shift 2
            ;;
        -h|--help)
            echo "用法: $0 -u username -p password"
            exit 0
            ;;
        *)
            echo "未知参数: $1"
            exit 1
            ;;
    esac
done

echo "用户名: $USERNAME"
echo "密码: $PASSWORD"
```

### 使用getopts处理参数
```bash
#!/bin/bash
# 处理短选项

while getopts "u:p:h" opt; do
    case $opt in
        u)
            USERNAME="$OPTARG"
            ;;
        p)
            PASSWORD="$OPTARG"
            ;;
        h)
            echo "用法: $0 -u username -p password"
            exit 0
            ;;
        \?)
            echo "无效选项: -$OPTARG" >&2
            exit 1
            ;;
        :)
            echo "选项 -$OPTARG 需要参数" >&2
            exit 1
            ;;
    esac
done

shift $((OPTIND-1))  # 移除已处理的选项
echo "剩余参数: $@"
```

## 4. 数组高级操作

### 关联数组（字典）
```bash
#!/bin/bash
# 声明关联数组（也就是字典）
declare -A student_scores

# 添加元素
student_scores["张三"]=85
student_scores["李四"]=92
student_scores["王五"]=78

#统计字典长度
echo "字典的长度是：${#student_scores[@]}"  

# 访问元素
echo "张三的成绩: ${student_scores["张三"]}"

# 遍历数组
for name in "${!student_scores[@]}"; do
    echo "$name: ${student_scores[$name]}"
done

# 获取所有键和值
echo "所有学生: ${!student_scores[@]}"
echo "所有成绩: ${student_scores[@]}"
```

### 数组操作函数
```bash
#!/bin/bash

# 数组追加函数
append_to_array() {
    local -n arr_ref=$1  # 使用nameref
    local value=$2
    arr_ref+=("$value")
}

# 数组查找函数
find_in_array() {
    local -n arr_ref=$1
    local target=$2
    
    for item in "${arr_ref[@]}"; do
        if [[ "$item" == "$target" ]]; then
            return 0  # 找到了,此外return只是退出函数，但是后续脚本还会继续执行
        fi
    done
    return 1  # 没找到
}

# 使用示例
fruits=("苹果" "香蕉")
append_to_array fruits "橙子"

if find_in_array fruits "苹果"; then
    echo "找到了苹果"
fi
```

## 5. 变量类型和属性

### 变量属性设置
```bash
# 1. 基本变量声明
echo -e "\n1. 基本变量声明"
declare name="张三" #等同于name="张三"
declare age=25 #等同于age=25
echo "姓名: $name, 年龄: $age"

# 2. 整数变量 (-i)
echo -e "\n2. 整数变量声明 (-i)"
declare -i number=10
echo "初始值: $number"
number="20"
echo "赋值字符串'20': $number"
number="hello"  # 非数字会被转换为0
echo "赋值字符串'hello': $number"
number=5+3      # 可以进行算术运算
echo "赋值'5+3': $number"

# 3. 只读变量 (-r)
echo -e "\n3. 只读变量声明 (-r)"
declare -r CONSTANT="不可修改"
echo "常量值: $CONSTANT"
# CONSTANT="新值"  # 取消注释会报错

# 4. 数组变量 (-a)
echo -e "\n4. 索引数组声明 (-a)"
declare -a fruits=("苹果" "香蕉" "橙子")
echo "水果数组: ${fruits[@]}"
echo "第一个水果: ${fruits[0]}"
echo "数组长度: ${#fruits[@]}"

# 添加元素
fruits+=("葡萄")
echo "添加葡萄后: ${fruits[@]}"

# 5. 关联数组 (-A)
echo -e "\n5. 关联数组声明 (-A)"
declare -A student_scores
student_scores["张三"]=85
student_scores["李四"]=92
student_scores["王五"]=78

echo "学生成绩:"
for name in "${!student_scores[@]}"; do
    echo "  $name: ${student_scores[$name]}分"
done

# 6. 环境变量 (-x)
echo -e "\n6. 环境变量声明 (-x)"
declare -x MY_ENV_VAR="环境变量值"
echo "环境变量: $MY_ENV_VAR"
# 子进程可以访问这个变量

# 7. 大小写转换 (-u, -l)
echo -e "\n7. 大小写转换"
declare -u uppercase_var="hello world"
declare -l lowercase_var="HELLO WORLD"
echo "转大写: $uppercase_var"
echo "转小写: $lowercase_var"

# 8. 名称引用 (-n)
echo -e "\n8. 名称引用 (-n)"
original_var="原始值"
declare -n ref_var=original_var
echo "通过引用访问: $ref_var"
ref_var="通过引用修改的值"
echo "原变量值: $original_var"

# 9. 查看变量属性 (-p)
echo -e "\n9. 查看变量属性 (-p)"
declare -i test_int=42
declare -r test_readonly="只读"
declare -A test_assoc=([key1]="value1" [key2]="value2")

echo "整数变量属性:"
declare -p test_int

echo "只读变量属性:"
declare -p test_readonly

echo "关联数组属性:"
declare -p test_assoc

# 10. 组合选项使用
echo -e "\n10. 组合选项使用"
declare -irx MAX_CONNECTIONS=100  # 整数+只读+环境变量
echo "最大连接数: $MAX_CONNECTIONS"
declare -p MAX_CONNECTIONS

# 11. 函数中使用 nameref
echo -e "\n11. 函数中使用 nameref"

# 数组操作函数
array_operations() {
    local -n arr_ref=$1
    local operation=$2
    
    case $operation in
        "add")
            local value=$3
            arr_ref+=("$value")
            echo "添加元素: $value"
            ;;
        "sum")
            local sum=0
            for num in "${arr_ref[@]}"; do
                ((sum += num))
            done
            echo "数组总和: $sum"
            ;;
        "length")
            echo "数组长度: ${#arr_ref[@]}"
            ;;
        "reverse")
            local temp_array=()
            for ((i=${#arr_ref[@]}-1; i>=0; i--)); do
                temp_array+=("${arr_ref[i]}")
            done
            arr_ref=("${temp_array[@]}")
            echo "数组已反转"
            ;;
    esac
}

# 测试数组操作
numbers=(1 2 3 4 5)
echo "原始数组: ${numbers[@]}"

array_operations numbers "sum"
array_operations numbers "length"
array_operations numbers "add" 6
echo "添加后: ${numbers[@]}"
array_operations numbers "reverse"
echo "反转后: ${numbers[@]}"

# 12. 配置管理示例
echo -e "\n12. 配置管理示例"

# 声明配置结构
declare -A app_config
declare -r CONFIG_VERSION="1.0"
declare -i DEFAULT_PORT=8080

# 初始化配置
init_config() {
    local -n config_ref=$1
    
    config_ref["app_name"]="MyApp"
    config_ref["version"]="1.0.0"
    config_ref["debug"]="false"
    config_ref["port"]="$DEFAULT_PORT"
    config_ref["database_url"]="localhost:3306"
}

# 显示配置
show_config() {
    local -n config_ref=$1
    
    echo "应用配置 (版本: $CONFIG_VERSION):"
    for key in "${!config_ref[@]}"; do
        echo "  $key = ${config_ref[$key]}"
    done
}

# 更新配置
update_config() {
    local -n config_ref=$1
    local key=$2
    local value=$3
    
    if [[ -n "${config_ref[$key]}" ]]; then
        echo "更新配置: $key = $value"
        config_ref[$key]="$value"
    else
        echo "警告: 配置项 '$key' 不存在"
    fi
}

# 使用配置管理
init_config app_config
show_config app_config

update_config app_config "port" "9000"
update_config app_config "debug" "true"
echo -e "\n更新后的配置:"
show_config app_config

# 13. 类型检查函数
echo -e "\n13. 变量类型检查"

check_variable_type() {
    local var_name=$1
    local attr_info
    
    # 检查变量是否存在
    if ! declare -p "$var_name" &>/dev/null; then
        echo "变量 '$var_name' 不存在"
        return 1
    fi
    
    # 获取变量属性
    attr_info=$(declare -p "$var_name" 2>/dev/null)
    
    echo "变量 '$var_name' 的属性:"
    
    if [[ $attr_info =~ declare\ -[^\ ]*i ]]; then
        echo "  - 整数类型"
    fi
    
    if [[ $attr_info =~ declare\ -[^\ ]*r ]]; then
        echo "  - 只读"
    fi
    
    if [[ $attr_info =~ declare\ -[^\ ]*x ]]; then
        echo "  - 环境变量"
    fi
    
    if [[ $attr_info =~ declare\ -[^\ ]*a ]]; then
        echo "  - 索引数组"
    fi
    
    if [[ $attr_info =~ declare\ -[^\ ]*A ]]; then
        echo "  - 关联数组"
    fi
    
    if [[ $attr_info =~ declare\ -[^\ ]*n ]]; then
        echo "  - 名称引用"
    fi
}

# 测试类型检查
check_variable_type "number"
check_variable_type "CONSTANT"
check_variable_type "fruits"
check_variable_type "student_scores"
check_variable_type "ref_var"

echo -e "\n=== declare 命令演示完成 ==="
```

## 实践练习

### 练习1：配置文件解析器
```bash
#!/bin/bash
# config_parser.sh - 解析配置文件

declare -A config

parse_config() {
    local config_file=$1
    
    while IFS='=' read -r key value; do  #IFS='=' 会将这行内容按等号分割并分配给key,value：
        # 跳过注释和空行
        [[ $key =~ ^[[:space:]]*# ]] && continue
        [[ -z $key ]] && continue
        
        # 去除前后空格
        key=$(echo "$key" | xargs)
        value=$(echo "$value" | xargs)
        
        config["$key"]="$value"
    done < "$config_file"
}

# 使用示例
cat > sample.conf << EOF
# 这是配置文件
database_host = localhost
database_port = 3306
database_name = myapp
# 用户配置
username = admin
password = secret123
EOF

parse_config "sample.conf"

# 显示配置
for key in "${!config[@]}"; do
    echo "$key = ${config[$key]}"
done
```

### 练习2：命令行工具模板
```bash
#!/bin/bash
# tool_template.sh - 通用命令行工具模板

# 默认值
VERBOSE=false
DRY_RUN=false
CONFIG_FILE=""

# 帮助信息
show_help() {
    cat << EOF
用法: $0 [选项] <命令> [参数...]

选项:
    -v, --verbose       详细输出
    -n, --dry-run       模拟运行，不执行实际操作
    -c, --config FILE   指定配置文件
    -h, --help          显示此帮助信息

命令:
    start               启动服务
    stop                停止服务
    status              查看状态
    restart             重启服务

示例:
    $0 -v start
    $0 --config /etc/myapp.conf restart
EOF
}

# 日志函数
log() {
    local level=$1
    shift
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [$level] $*"
}

verbose_log() {
    $VERBOSE && log "INFO" "$@"
}

# 参数解析
while [[ $# -gt 0 ]]; do
    case $1 in
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        -n|--dry-run)
            DRY_RUN=true
            shift
            ;;
        -c|--config)
            CONFIG_FILE="$2"
            shift 2
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        -*)
            echo "未知选项: $1" >&2
            exit 1
            ;;
        *)
            break
            ;;
    esac
done

# 检查是否提供了命令
if [[ $# -eq 0 ]]; then
    echo "错误: 请提供命令" >&2
    show_help
    exit 1
fi

COMMAND=$1
shift

verbose_log "执行命令: $COMMAND"
verbose_log "详细模式: $VERBOSE"
verbose_log "模拟运行: $DRY_RUN"
verbose_log "配置文件: $CONFIG_FILE"

# 命令处理
case $COMMAND in
    start)
        log "INFO" "启动服务..."
        $DRY_RUN && log "INFO" "[模拟] 服务已启动" || log "INFO" "服务已启动"
        ;;
    stop)
        log "INFO" "停止服务..."
        $DRY_RUN && log "INFO" "[模拟] 服务已停止" || log "INFO" "服务已停止"
        ;;
    status)
        log "INFO" "检查服务状态..."
        ;;
    restart)
        log "INFO" "重启服务..."
        ;;
    *)
        echo "未知命令: $COMMAND" >&2
        exit 1
        ;;
esac
```

## 最佳实践

1. **变量命名**：使用描述性名称，常量用大写，变量用小写
2. **引号使用**：变量替换时总是使用双引号 `"$var"`
3. **参数验证**：总是验证必需参数是否存在
4. **错误处理**：使用适当的退出码和错误信息
5. **文档化**：为复杂脚本提供帮助信息