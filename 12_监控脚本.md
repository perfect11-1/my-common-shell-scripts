# Shell脚本系统监控

## 概述
系统监控是运维工作的核心，Shell脚本提供了灵活高效的监控解决方案，可以实时监控系统资源、服务状态和应用性能。

## 基础监控脚本

### 1. 系统资源监控
```bash
#!/bin/bash

# 系统资源监控脚本
HOSTNAME=$(hostname)
TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')

echo "=== 系统监控报告 ==="
echo "主机名: $HOSTNAME"
echo "时间: $TIMESTAMP"
echo

# CPU使用率
echo "=== CPU使用率 ==="
cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1)
echo "CPU使用率: ${cpu_usage}%"

# 内存使用情况
echo "=== 内存使用情况 ==="
memory_info=$(free -h)
echo "$memory_info"

memory_usage=$(free | awk 'NR==2{printf "%.2f", $3*100/$2}')
echo "内存使用率: ${memory_usage}%"

# 磁盘使用情况
echo "=== 磁盘使用情况 ==="
df -h | grep -E '^/dev/'

# 系统负载
echo "=== 系统负载 ==="
uptime

# 网络连接
echo "=== 网络连接统计 ==="
netstat -an | awk '/^tcp/ {++state[$NF]} END {for(key in state) print key, state[key]}'

# 进程统计
echo "=== 进程统计 ==="
echo "总进程数: $(ps aux | wc -l)"
echo "运行中进程: $(ps aux | awk '$8 ~ /^R/ {count++} END {print count+0}')"
echo "睡眠进程: $(ps aux | awk '$8 ~ /^S/ {count++} END {print count+0}')"
```

### 2. 服务状态监控
```bash
#!/bin/bash

# 服务状态监控脚本
SERVICES=("nginx" "mysql" "redis" "ssh")
ALERT_EMAIL="admin@example.com"
LOG_FILE="/var/log/service_monitor.log"

check_service() {
    local service="$1"
    
    if systemctl is-active --quiet "$service"; then
        echo "✅ $service 运行正常"
        return 0
    else
        echo "❌ $service 服务异常"
        return 1
    fi
}

restart_service() {
    local service="$1"
    
    echo "尝试重启服务: $service"
    if systemctl restart "$service"; then
        echo "✅ $service 重启成功"
        echo "$(date): $service 重启成功" >> "$LOG_FILE"
        return 0
    else
        echo "❌ $service 重启失败"
        echo "$(date): $service 重启失败" >> "$LOG_FILE"
        return 1
    fi
}

send_alert() {
    local service="$1"
    local status="$2"
    
    local subject="服务监控警报 - $service"
    local message="主机: $(hostname)
时间: $(date)
服务: $service
状态: $status

请立即检查服务状态。"
    
    echo "$message" | mail -s "$subject" "$ALERT_EMAIL"
}

# 主监控循环
echo "开始服务监控 - $(date)"

for service in "${SERVICES[@]}"; do
    if ! check_service "$service"; then
        # 服务异常，尝试重启
        if restart_service "$service"; then
            send_alert "$service" "重启成功"
        else
            send_alert "$service" "重启失败"
        fi
    fi
done

echo "服务监控完成 - $(date)"
```

### 3. 网络监控脚本
```bash
#!/bin/bash

# 网络监控脚本
HOSTS=("google.com" "github.com" "stackoverflow.com")
TIMEOUT=5
LOG_FILE="/var/log/network_monitor.log"

check_connectivity() {
    local host="$1"
    local timeout="$2"
    
    if ping -c 1 -W "$timeout" "$host" > /dev/null 2>&1; then
        echo "✅ $host 连接正常"
        return 0
    else
        echo "❌ $host 连接失败"
        return 1
    fi
}

check_dns() {
    local host="$1"
    
    if nslookup "$host" > /dev/null 2>&1; then
        echo "✅ $host DNS解析正常"
        return 0
    else
        echo "❌ $host DNS解析失败"
        return 1
    fi
}

check_port() {
    local host="$1"
    local port="$2"
    local timeout="$3"
    
    if timeout "$timeout" bash -c "echo >/dev/tcp/$host/$port" 2>/dev/null; then
        echo "✅ $host:$port 端口开放"
        return 0
    else
        echo "❌ $host:$port 端口关闭或超时"
        return 1
    fi
}

# 网络接口状态
echo "=== 网络接口状态 ==="
ip addr show | grep -E '^[0-9]+:|inet '

# 路由表
echo "=== 路由表 ==="
ip route

# 连通性测试
echo "=== 连通性测试 ==="
for host in "${HOSTS[@]}"; do
    check_connectivity "$host" "$TIMEOUT"
    check_dns "$host"
done

# 端口检查
echo "=== 端口检查 ==="
check_port "localhost" "22" "$TIMEOUT"  # SSH
check_port "localhost" "80" "$TIMEOUT"  # HTTP
check_port "localhost" "443" "$TIMEOUT" # HTTPS

# 网络统计
echo "=== 网络统计 ==="
ss -tuln
```

## 高级监控脚本

### 1. 应用性能监控
```bash
#!/bin/bash

# 应用性能监控脚本
APP_NAME="myapp"
APP_URL="http://localhost:3000"
HEALTH_ENDPOINT="$APP_URL/health"
METRICS_ENDPOINT="$APP_URL/metrics"
ALERT_THRESHOLD_RESPONSE_TIME=2.0
ALERT_THRESHOLD_ERROR_RATE=5.0

# 响应时间检查
check_response_time() {
    local url="$1"
    local threshold="$2"
    
    local response_time=$(curl -o /dev/null -s -w '%{time_total}' "$url")
    local status_code=$(curl -o /dev/null -s -w '%{http_code}' "$url")
    
    echo "响应时间: ${response_time}s, 状态码: $status_code"
    
    if (( $(echo "$response_time > $threshold" | bc -l) )); then
        echo "⚠️ 响应时间超过阈值 (${threshold}s)"
        return 1
    fi
    
    if [ "$status_code" != "200" ]; then
        echo "❌ HTTP状态码异常: $status_code"
        return 1
    fi
    
    return 0
}

# 错误率检查
check_error_rate() {
    local log_file="$1"
    local time_window="$2"  # 分钟
    
    local total_requests=$(grep "$(date -d "$time_window minutes ago" '+%Y-%m-%d %H:%M')" "$log_file" | wc -l)
    local error_requests=$(grep "$(date -d "$time_window minutes ago" '+%Y-%m-%d %H:%M')" "$log_file" | grep -E "50[0-9]|40[4-9]" | wc -l)
    
    if [ "$total_requests" -eq 0 ]; then
        echo "没有请求数据"
        return 0
    fi
    
    local error_rate=$(echo "scale=2; $error_requests * 100 / $total_requests" | bc)
    echo "错误率: ${error_rate}% (${error_requests}/${total_requests})"
    
    if (( $(echo "$error_rate > $ALERT_THRESHOLD_ERROR_RATE" | bc -l) )); then
        echo "⚠️ 错误率超过阈值 (${ALERT_THRESHOLD_ERROR_RATE}%)"
        return 1
    fi
    
    return 0
}

# 内存泄漏检查
check_memory_leak() {
    local process_name="$1"
    local threshold_mb="$2"
    
    local memory_usage=$(ps aux | grep "$process_name" | grep -v grep | awk '{sum+=$6} END {print sum/1024}')
    
    if [ -z "$memory_usage" ]; then
        echo "进程 $process_name 未找到"
        return 1
    fi
    
    echo "内存使用: ${memory_usage}MB"
    
    if (( $(echo "$memory_usage > $threshold_mb" | bc -l) )); then
        echo "⚠️ 内存使用超过阈值 (${threshold_mb}MB)"
        return 1
    fi
    
    return 0
}

# 数据库连接池监控
check_db_connections() {
    local max_connections="$1"
    
    local current_connections=$(mysql -e "SHOW STATUS LIKE 'Threads_connected';" | awk 'NR==2 {print $2}')
    local connection_usage=$(echo "scale=2; $current_connections * 100 / $max_connections" | bc)
    
    echo "数据库连接: ${current_connections}/${max_connections} (${connection_usage}%)"
    
    if (( $(echo "$connection_usage > 80" | bc -l) )); then
        echo "⚠️ 数据库连接使用率过高"
        return 1
    fi
    
    return 0
}

# 执行监控
echo "=== 应用性能监控 - $(date) ==="
echo "应用: $APP_NAME"
echo

echo "1. 健康检查"
check_response_time "$HEALTH_ENDPOINT" "$ALERT_THRESHOLD_RESPONSE_TIME"
echo

echo "2. 错误率检查"
check_error_rate "/var/log/nginx/access.log" 5
echo

echo "3. 内存使用检查"
check_memory_leak "$APP_NAME" 512
echo

echo "4. 数据库连接检查"
check_db_connections 100
```

### 2. 日志监控脚本
```bash
#!/bin/bash

# 日志监控脚本
LOG_FILES=(
    "/var/log/syslog"
    "/var/log/nginx/error.log"
    "/var/log/mysql/error.log"
    "/var/log/application.log"
)

ERROR_PATTERNS=(
    "ERROR"
    "CRITICAL"
    "FATAL"
    "Exception"
    "failed"
    "timeout"
)

ALERT_EMAIL="admin@example.com"
CHECK_INTERVAL=300  # 5分钟

monitor_log_file() {
    local log_file="$1"
    local since_time="$2"
    
    if [ ! -f "$log_file" ]; then
        echo "日志文件不存在: $log_file"
        return 1
    fi
    
    echo "监控日志文件: $log_file"
    
    # 获取指定时间后的日志
    local recent_logs=$(find "$log_file" -newermt "$since_time" -exec cat {} \;)
    
    if [ -z "$recent_logs" ]; then
        echo "没有新的日志条目"
        return 0
    fi
    
    # 检查错误模式
    local errors_found=false
    for pattern in "${ERROR_PATTERNS[@]}"; do
        local matches=$(echo "$recent_logs" | grep -i "$pattern")
        if [ -n "$matches" ]; then
            echo "发现错误模式 '$pattern':"
            echo "$matches"
            errors_found=true
        fi
    done
    
    if [ "$errors_found" = true ]; then
        return 1
    fi
    
    return 0
}

# 发送警报
send_log_alert() {
    local log_file="$1"
    local errors="$2"
    
    local subject="日志监控警报 - $(basename "$log_file")"
    local message="主机: $(hostname)
时间: $(date)
日志文件: $log_file

发现的错误:
$errors

请检查系统状态。"
    
    echo "$message" | mail -s "$subject" "$ALERT_EMAIL"
}

# 主监控循环
while true; do
    echo "开始日志监控 - $(date)"
    
    # 计算检查时间点
    since_time=$(date -d "$CHECK_INTERVAL seconds ago" '+%Y-%m-%d %H:%M:%S')
    
    for log_file in "${LOG_FILES[@]}"; do
        if ! monitor_log_file "$log_file" "$since_time"; then
            echo "在 $log_file 中发现错误"
            # 这里可以添加发送警报的逻辑
        fi
        echo
    done
    
    echo "等待 $CHECK_INTERVAL 秒..."
    sleep "$CHECK_INTERVAL"
done
```

### 3. 综合监控仪表板
```bash
#!/bin/bash

# 综合监控仪表板脚本
DASHBOARD_FILE="/tmp/monitoring_dashboard.html"
REFRESH_INTERVAL=30

generate_dashboard() {
    cat > "$DASHBOARD_FILE" << 'EOF'
<!DOCTYPE html>
<html>
<head>
    <title>系统监控仪表板</title>
    <meta charset="utf-8">
    <meta http-equiv="refresh" content="30">
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; }
        .header { background-color: #333; color: white; padding: 20px; border-radius: 5px; margin-bottom: 20px; }
        .section { background-color: white; padding: 20px; margin-bottom: 20px; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .metric { display: inline-block; margin: 10px; padding: 15px; background-color: #f8f9fa; border-radius: 5px; min-width: 150px; }
        .status-ok { color: #28a745; }
        .status-warning { color: #ffc107; }
        .status-error { color: #dc3545; }
        .progress-bar { width: 100%; height: 20px; background-color: #e9ecef; border-radius: 10px; overflow: hidden; }
        .progress-fill { height: 100%; background-color: #007bff; transition: width 0.3s ease; }
        pre { background-color: #f8f9fa; padding: 10px; border-radius: 5px; overflow-x: auto; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>系统监控仪表板</h1>
            <p>主机: $(hostname) | 更新时间: $(date)</p>
        </div>
EOF

    # 系统资源部分
    cat >> "$DASHBOARD_FILE" << EOF
        <div class="section">
            <h2>系统资源</h2>
            <div class="metric">
                <h4>CPU使用率</h4>
                <div class="progress-bar">
                    <div class="progress-fill" style="width: $(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1)%"></div>
                </div>
                <p>$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1)%</p>
            </div>
            <div class="metric">
                <h4>内存使用率</h4>
                <div class="progress-bar">
                    <div class="progress-fill" style="width: $(free | awk 'NR==2{printf "%.0f", $3*100/$2}')%"></div>
                </div>
                <p>$(free | awk 'NR==2{printf "%.1f", $3*100/$2}')%</p>
            </div>
            <div class="metric">
                <h4>磁盘使用率</h4>
                <p>$(df -h / | awk 'NR==2{print $5}')</p>
            </div>
            <div class="metric">
                <h4>系统负载</h4>
                <p>$(uptime | awk -F'load average:' '{print $2}')</p>
            </div>
        </div>
EOF

    # 服务状态部分
    cat >> "$DASHBOARD_FILE" << 'EOF'
        <div class="section">
            <h2>服务状态</h2>
EOF

    local services=("nginx" "mysql" "ssh")
    for service in "${services[@]}"; do
        if systemctl is-active --quiet "$service" 2>/dev/null; then
            status_class="status-ok"
            status_text="运行中"
        else
            status_class="status-error"
            status_text="已停止"
        fi
        
        cat >> "$DASHBOARD_FILE" << EOF
            <div class="metric">
                <h4>$service</h4>
                <p class="$status_class">$status_text</p>
            </div>
EOF
    done

    # 网络状态部分
    cat >> "$DASHBOARD_FILE" << 'EOF'
        </div>
        
        <div class="section">
            <h2>网络状态</h2>
            <pre>
EOF
    
    netstat -i >> "$DASHBOARD_FILE"
    
    cat >> "$DASHBOARD_FILE" << 'EOF'
            </pre>
        </div>
        
        <div class="section">
            <h2>最近的系统日志</h2>
            <pre>
EOF
    
    tail -20 /var/log/syslog >> "$DASHBOARD_FILE" 2>/dev/null || echo "无法访问系统日志" >> "$DASHBOARD_FILE"
    
    cat >> "$DASHBOARD_FILE" << 'EOF'
            </pre>
        </div>
    </div>
</body>
</html>
EOF
}

# 启动Web服务器
start_web_server() {
    local port="${1:-8080}"
    
    echo "启动监控仪表板服务器，端口: $port"
    echo "访问地址: http://localhost:$port"
    
    # 使用Python启动简单的HTTP服务器
    cd "$(dirname "$DASHBOARD_FILE")"
    python3 -m http.server "$port" > /dev/null 2>&1 &
    local server_pid=$!
    
    echo "服务器PID: $server_pid"
    echo "$server_pid" > /tmp/dashboard_server.pid
}

# 主循环
main() {
    local port="${1:-8080}"
    
    # 启动Web服务器
    start_web_server "$port"
    
    # 定期更新仪表板
    while true; do
        echo "更新仪表板 - $(date)"
        generate_dashboard
        sleep "$REFRESH_INTERVAL"
    done
}

# 清理函数
cleanup() {
    if [ -f /tmp/dashboard_server.pid ]; then
        local pid=$(cat /tmp/dashboard_server.pid)
        kill "$pid" 2>/dev/null
        rm -f /tmp/dashboard_server.pid
    fi
    rm -f "$DASHBOARD_FILE"
    echo "清理完成"
}

# 信号处理
trap cleanup EXIT INT TERM

# 运行主程序
main "$@"
```

## 监控脚本最佳实践

### 1. 配置文件管理
```bash
# 监控配置文件 /etc/monitoring/config.conf
ALERT_EMAIL="admin@example.com"
SLACK_WEBHOOK="https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK"
CHECK_INTERVAL=300
CPU_THRESHOLD=80
MEMORY_THRESHOLD=85
DISK_THRESHOLD=90
RESPONSE_TIME_THRESHOLD=2.0

# 在脚本中加载配置
if [ -f "/etc/monitoring/config.conf" ]; then
    source "/etc/monitoring/config.conf"
fi
```

### 2. 日志记录
```bash
# 统一日志记录函数
log_message() {
    local level="$1"
    local message="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    echo "[$timestamp] [$level] $message" | tee -a "$LOG_FILE"
}

# 使用示例
log_message "INFO" "开始系统监控"
log_message "WARNING" "CPU使用率过高: 85%"
log_message "ERROR" "服务nginx已停止"
```

## 实践练习

1. 编写一个完整的系统资源监控脚本，包括CPU、内存、磁盘和网络监控
2. 创建服务健康检查脚本，自动重启异常服务
3. 实现日志监控系统，能够检测和报告错误模式
4. 编写性能监控脚本，监控应用响应时间和错误率
5. 创建监控仪表板，实时显示系统状态

## 总结

系统监控脚本的核心要素：
- **全面性**: 覆盖系统资源、服务状态、应用性能等各个方面
- **实时性**: 及时发现和报告问题
- **自动化**: 自动检测、重启和恢复
- **可视化**: 提供直观的监控界面
- **可扩展性**: 易于添加新的监控项目

掌握这些监控技能将大大提高系统运维效率和稳定性。