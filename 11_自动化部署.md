# Shell脚本自动化部署

## 概述
自动化部署是现代软件开发的重要环节，Shell脚本提供了灵活而强大的部署自动化解决方案。

## 部署脚本基础

### 1. 基本部署流程
```bash
#!/bin/bash

# 基本部署脚本模板
set -e  # 遇到错误立即退出

# 配置变量
APP_NAME="myapp"
DEPLOY_DIR="/opt/$APP_NAME"
BACKUP_DIR="/opt/backups"
GIT_REPO="https://github.com/user/myapp.git"
BRANCH="main"

echo "开始部署 $APP_NAME..."

# 1. 创建备份
echo "创建备份..."
if [ -d "$DEPLOY_DIR" ]; then
    tar -czf "$BACKUP_DIR/${APP_NAME}_$(date +%Y%m%d_%H%M%S).tar.gz" -C "$DEPLOY_DIR" .
fi

# 2. 拉取最新代码
echo "拉取最新代码..."
if [ -d "$DEPLOY_DIR" ]; then
    cd "$DEPLOY_DIR"
    git pull origin "$BRANCH"
else
    git clone -b "$BRANCH" "$GIT_REPO" "$DEPLOY_DIR"
    cd "$DEPLOY_DIR"
fi

# 3. 安装依赖
echo "安装依赖..."
if [ -f "package.json" ]; then
    npm install --production
elif [ -f "requirements.txt" ]; then
    pip install -r requirements.txt
elif [ -f "Gemfile" ]; then
    bundle install
fi

# 4. 构建应用
echo "构建应用..."
if [ -f "Makefile" ]; then
    make build
elif [ -f "package.json" ]; then
    npm run build
fi

# 5. 重启服务
echo "重启服务..."
systemctl restart "$APP_NAME"

echo "部署完成！"
```

### 2. 配置管理
```bash
#!/bin/bash

# 配置文件管理脚本
CONFIG_DIR="/etc/myapp"
CONFIG_TEMPLATE_DIR="./config/templates"
ENVIRONMENT="${1:-production}"

deploy_config() {
    local env="$1"
    
    echo "部署 $env 环境配置..."
    
    # 创建配置目录
    mkdir -p "$CONFIG_DIR"
    
    # 复制配置模板
    for template in "$CONFIG_TEMPLATE_DIR"/*.template; do
        if [ -f "$template" ]; then
            config_file="$CONFIG_DIR/$(basename "$template" .template)"
            
            # 替换环境变量
            envsubst < "$template" > "$config_file"
            
            # 设置权限
            chmod 644 "$config_file"
            
            echo "已部署配置文件: $config_file"
        fi
    done
}

# 环境变量设置
case "$ENVIRONMENT" in
    "production")
        export DB_HOST="prod-db.example.com"
        export DB_PORT="5432"
        export LOG_LEVEL="INFO"
        ;;
    "staging")
        export DB_HOST="staging-db.example.com"
        export DB_PORT="5432"
        export LOG_LEVEL="DEBUG"
        ;;
    "development")
        export DB_HOST="localhost"
        export DB_PORT="5432"
        export LOG_LEVEL="DEBUG"
        ;;
    *)
        echo "未知环境: $ENVIRONMENT"
        exit 1
        ;;
esac

deploy_config "$ENVIRONMENT"
```

## 高级部署脚本

### 1. 蓝绿部署脚本
```bash
#!/bin/bash

# 蓝绿部署脚本
set -e

APP_NAME="myapp"
BLUE_DIR="/opt/${APP_NAME}-blue"
GREEN_DIR="/opt/${APP_NAME}-green"
CURRENT_LINK="/opt/${APP_NAME}-current"
NGINX_CONFIG="/etc/nginx/sites-available/${APP_NAME}"

# 检查当前活跃环境
get_active_env() {
    if [ -L "$CURRENT_LINK" ]; then
        local target=$(readlink "$CURRENT_LINK")
        if [[ "$target" == *"blue"* ]]; then
            echo "blue"
        else
            echo "green"
        fi
    else
        echo "blue"  # 默认
    fi
}

# 获取非活跃环境
get_inactive_env() {
    local active=$(get_active_env)
    if [ "$active" = "blue" ]; then
        echo "green"
    else
        echo "blue"
    fi
}

# 部署到非活跃环境
deploy_to_inactive() {
    local inactive_env=$(get_inactive_env)
    local deploy_dir
    
    if [ "$inactive_env" = "blue" ]; then
        deploy_dir="$BLUE_DIR"
    else
        deploy_dir="$GREEN_DIR"
    fi
    
    echo "部署到 $inactive_env 环境: $deploy_dir"
    
    # 清理旧版本
    rm -rf "$deploy_dir"
    
    # 克隆新版本
    git clone https://github.com/user/myapp.git "$deploy_dir"
    cd "$deploy_dir"
    
    # 安装依赖和构建
    npm install --production
    npm run build
    
    # 启动服务（不同端口）
    if [ "$inactive_env" = "blue" ]; then
        PORT=3001 npm start &
    else
        PORT=3002 npm start &
    fi
    
    # 等待服务启动
    sleep 10
    
    # 健康检查
    local port
    if [ "$inactive_env" = "blue" ]; then
        port=3001
    else
        port=3002
    fi
    
    if curl -f "http://localhost:$port/health"; then
        echo "$inactive_env 环境部署成功"
        return 0
    else
        echo "$inactive_env 环境部署失败"
        return 1
    fi
}

# 切换流量
switch_traffic() {
    local new_active=$(get_inactive_env)
    local new_dir
    
    if [ "$new_active" = "blue" ]; then
        new_dir="$BLUE_DIR"
        new_port=3001
    else
        new_dir="$GREEN_DIR"
        new_port=3002
    fi
    
    echo "切换流量到 $new_active 环境"
    
    # 更新nginx配置
    sed -i "s/proxy_pass http:\/\/localhost:[0-9]*/proxy_pass http:\/\/localhost:$new_port/" "$NGINX_CONFIG"
    
    # 重新加载nginx
    nginx -s reload
    
    # 更新当前链接
    ln -sfn "$new_dir" "$CURRENT_LINK"
    
    echo "流量已切换到 $new_active 环境"
}

# 回滚
rollback() {
    local current_active=$(get_active_env)
    local rollback_env
    
    if [ "$current_active" = "blue" ]; then
        rollback_env="green"
        rollback_port=3002
    else
        rollback_env="blue"
        rollback_port=3001
    fi
    
    echo "回滚到 $rollback_env 环境"
    
    # 更新nginx配置
    sed -i "s/proxy_pass http:\/\/localhost:[0-9]*/proxy_pass http:\/\/localhost:$rollback_port/" "$NGINX_CONFIG"
    nginx -s reload
    
    # 更新当前链接
    if [ "$rollback_env" = "blue" ]; then
        ln -sfn "$BLUE_DIR" "$CURRENT_LINK"
    else
        ln -sfn "$GREEN_DIR" "$CURRENT_LINK"
    fi
    
    echo "已回滚到 $rollback_env 环境"
}

# 主逻辑
case "${1:-deploy}" in
    "deploy")
        deploy_to_inactive && switch_traffic
        ;;
    "rollback")
        rollback
        ;;
    "status")
        echo "当前活跃环境: $(get_active_env)"
        ;;
    *)
        echo "用法: $0 {deploy|rollback|status}"
        exit 1
        ;;
esac
```

### 2. 容器化部署脚本
```bash
#!/bin/bash

# Docker容器化部署脚本
set -e

APP_NAME="myapp"
IMAGE_NAME="myapp:latest"
CONTAINER_NAME="${APP_NAME}-container"
DOCKER_REGISTRY="registry.example.com"

# 构建Docker镜像
build_image() {
    echo "构建Docker镜像..."
    
    # 构建镜像
    docker build -t "$IMAGE_NAME" .
    
    # 标记镜像
    docker tag "$IMAGE_NAME" "$DOCKER_REGISTRY/$IMAGE_NAME"
    
    echo "镜像构建完成: $IMAGE_NAME"
}

# 推送镜像到仓库
push_image() {
    echo "推送镜像到仓库..."
    docker push "$DOCKER_REGISTRY/$IMAGE_NAME"
    echo "镜像推送完成"
}

# 部署容器
deploy_container() {
    echo "部署容器..."
    
    # 停止旧容器
    if docker ps -q -f name="$CONTAINER_NAME" | grep -q .; then
        echo "停止旧容器..."
        docker stop "$CONTAINER_NAME"
        docker rm "$CONTAINER_NAME"
    fi
    
    # 拉取最新镜像
    docker pull "$DOCKER_REGISTRY/$IMAGE_NAME"
    
    # 启动新容器
    docker run -d \
        --name "$CONTAINER_NAME" \
        --restart unless-stopped \
        -p 80:3000 \
        -e NODE_ENV=production \
        -v /opt/app/logs:/app/logs \
        "$DOCKER_REGISTRY/$IMAGE_NAME"
    
    # 等待容器启动
    sleep 10
    
    # 健康检查
    if docker exec "$CONTAINER_NAME" curl -f http://localhost:3000/health; then
        echo "容器部署成功"
    else
        echo "容器部署失败"
        exit 1
    fi
}

# 清理旧镜像
cleanup_images() {
    echo "清理旧镜像..."
    
    # 删除未使用的镜像
    docker image prune -f
    
    # 删除旧版本镜像（保留最新3个版本）
    docker images "$DOCKER_REGISTRY/$APP_NAME" --format "table {{.Repository}}:{{.Tag}}\t{{.CreatedAt}}" | \
    tail -n +2 | sort -k2 -r | tail -n +4 | awk '{print $1}' | xargs -r docker rmi
    
    echo "镜像清理完成"
}

# 主逻辑
case "${1:-all}" in
    "build")
        build_image
        ;;
    "push")
        push_image
        ;;
    "deploy")
        deploy_container
        ;;
    "cleanup")
        cleanup_images
        ;;
    "all")
        build_image
        push_image
        deploy_container
        cleanup_images
        ;;
    *)
        echo "用法: $0 {build|push|deploy|cleanup|all}"
        exit 1
        ;;
esac
```

### 3. 数据库迁移脚本
```bash
#!/bin/bash

# 数据库迁移脚本
set -e

DB_HOST="${DB_HOST:-localhost}"
DB_PORT="${DB_PORT:-5432}"
DB_NAME="${DB_NAME:-myapp}"
DB_USER="${DB_USER:-postgres}"
MIGRATION_DIR="./migrations"
MIGRATION_TABLE="schema_migrations"

# 检查数据库连接
check_db_connection() {
    echo "检查数据库连接..."
    if ! PGPASSWORD="$DB_PASSWORD" psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -c '\q' 2>/dev/null; then
        echo "错误: 无法连接到数据库"
        exit 1
    fi
    echo "数据库连接正常"
}

# 创建迁移表
create_migration_table() {
    PGPASSWORD="$DB_PASSWORD" psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -c "
        CREATE TABLE IF NOT EXISTS $MIGRATION_TABLE (
            version VARCHAR(255) PRIMARY KEY,
            applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );
    "
}

# 获取已应用的迁移
get_applied_migrations() {
    PGPASSWORD="$DB_PASSWORD" psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -t -c "
        SELECT version FROM $MIGRATION_TABLE ORDER BY version;
    " | tr -d ' '
}

# 获取待应用的迁移
get_pending_migrations() {
    local applied_migrations=$(get_applied_migrations)
    
    for migration_file in "$MIGRATION_DIR"/*.sql; do
        if [ -f "$migration_file" ]; then
            local version=$(basename "$migration_file" .sql)
            if ! echo "$applied_migrations" | grep -q "^$version$"; then
                echo "$version"
            fi
        fi
    done | sort
}

# 应用迁移
apply_migration() {
    local version="$1"
    local migration_file="$MIGRATION_DIR/$version.sql"
    
    echo "应用迁移: $version"
    
    # 开始事务
    PGPASSWORD="$DB_PASSWORD" psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -c "BEGIN;"
    
    # 执行迁移
    if PGPASSWORD="$DB_PASSWORD" psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -f "$migration_file"; then
        # 记录迁移
        PGPASSWORD="$DB_PASSWORD" psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -c "
            INSERT INTO $MIGRATION_TABLE (version) VALUES ('$version');
            COMMIT;
        "
        echo "迁移 $version 应用成功"
    else
        # 回滚事务
        PGPASSWORD="$DB_PASSWORD" psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -c "ROLLBACK;"
        echo "迁移 $version 应用失败"
        exit 1
    fi
}

# 运行所有待应用的迁移
run_migrations() {
    echo "开始数据库迁移..."
    
    check_db_connection
    create_migration_table
    
    local pending_migrations=$(get_pending_migrations)
    
    if [ -z "$pending_migrations" ]; then
        echo "没有待应用的迁移"
        return 0
    fi
    
    echo "待应用的迁移:"
    echo "$pending_migrations"
    
    for version in $pending_migrations; do
        apply_migration "$version"
    done
    
    echo "所有迁移应用完成"
}

# 创建新迁移文件
create_migration() {
    local name="$1"
    if [ -z "$name" ]; then
        echo "用法: $0 create <迁移名称>"
        exit 1
    fi
    
    local timestamp=$(date +%Y%m%d%H%M%S)
    local filename="${timestamp}_${name}.sql"
    local filepath="$MIGRATION_DIR/$filename"
    
    mkdir -p "$MIGRATION_DIR"
    
    cat > "$filepath" << EOF
-- Migration: $name
-- Created: $(date)

-- Add your SQL statements here
-- Example:
-- CREATE TABLE example (
--     id SERIAL PRIMARY KEY,
--     name VARCHAR(255) NOT NULL
-- );

EOF
    
    echo "创建迁移文件: $filepath"
}

# 主逻辑
case "${1:-migrate}" in
    "migrate")
        run_migrations
        ;;
    "create")
        create_migration "$2"
        ;;
    "status")
        check_db_connection
        create_migration_table
        echo "已应用的迁移:"
        get_applied_migrations
        echo
        echo "待应用的迁移:"
        get_pending_migrations
        ;;
    *)
        echo "用法: $0 {migrate|create|status}"
        exit 1
        ;;
esac
```

## 部署监控和通知

### 1. 部署状态监控
```bash
#!/bin/bash

# 部署状态监控脚本
WEBHOOK_URL="https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK"
APP_NAME="myapp"
HEALTH_URL="http://localhost:3000/health"

# 发送Slack通知
send_slack_notification() {
    local message="$1"
    local color="$2"
    
    curl -X POST -H 'Content-type: application/json' \
        --data "{\"attachments\":[{\"color\":\"$color\",\"text\":\"$message\"}]}" \
        "$WEBHOOK_URL"
}

# 健康检查
health_check() {
    local max_attempts=5
    local attempt=1
    
    while [ $attempt -le $max_attempts ]; do
        echo "健康检查尝试 $attempt/$max_attempts"
        
        if curl -f -s "$HEALTH_URL" > /dev/null; then
            echo "应用健康检查通过"
            send_slack_notification "✅ $APP_NAME 部署成功并通过健康检查" "good"
            return 0
        fi
        
        sleep 10
        ((attempt++))
    done
    
    echo "应用健康检查失败"
    send_slack_notification "❌ $APP_NAME 部署失败，健康检查未通过" "danger"
    return 1
}

# 性能检查
performance_check() {
    local response_time=$(curl -o /dev/null -s -w '%{time_total}' "$HEALTH_URL")
    local threshold=2.0
    
    if (( $(echo "$response_time > $threshold" | bc -l) )); then
        send_slack_notification "⚠️ $APP_NAME 响应时间较慢: ${response_time}s" "warning"
    fi
}

# 执行检查
health_check && performance_check
```

## 实践练习

1. 编写一个完整的Web应用部署脚本，包括代码拉取、依赖安装、构建和服务重启
2. 实现蓝绿部署机制，确保零停机部署
3. 创建数据库迁移管理系统
4. 编写部署回滚脚本，能够快速恢复到上一个版本
5. 实现部署状态监控和通知系统

## 总结

自动化部署脚本的关键要素：
- **可靠性**: 错误处理和回滚机制
- **可观测性**: 日志记录和状态监控
- **安全性**: 权限控制和敏感信息保护
- **灵活性**: 支持多环境和配置管理
- **效率**: 并行处理和缓存优化

掌握这些技能将大大提高部署效率和系统稳定性。