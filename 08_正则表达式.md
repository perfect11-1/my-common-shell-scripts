# 正则表达式详解

## 1. 正则表达式基础

### 基本概念
```bash
#!/bin/bash

# 正则表达式是用来匹配字符串模式的强大工具
# 在shell中主要通过以下方式使用：
# 1. [[ string =~ regex ]]  - bash内置正则匹配
# 2. grep -E "regex"        - 扩展正则表达式
# 3. sed 's/regex/replace/' - 流编辑器
# 4. awk '/regex/'          - 文本处理工具

text="Hello World 123"

# 基本匹配
if [[ $text =~ Hello ]]; then
    echo "匹配成功: Hello"
fi

# 使用grep
echo "$text" | grep -E "World"
echo "$text" | grep -E "[0-9]+"
```

### 基本元字符
```bash
#!/bin/bash

# . - 匹配任意单个字符（除换行符）
text="cat bat rat"
echo "$text" | grep -E "c.t"    # 匹配 cat

# ^ - 匹配行首
echo -e "hello\nworld\nhello world" | grep -E "^hello"

# $ - 匹配行尾
echo -e "hello\nworld\nhello world" | grep -E "world$"

# * - 匹配前面字符0次或多次
echo "gooooogle" | grep -E "go*gle"

# + - 匹配前面字符1次或多次
echo "gooogle" | grep -E "go+gle"

# ? - 匹配前面字符0次或1次
echo "color colour" | grep -E "colou?r"

# \ - 转义字符
echo "3.14" | grep -E "3\.14"
```

## 2. 字符类和量词

### 字符类
```bash
#!/bin/bash

text="Hello World 123 @#$"

# [abc] - 匹配方括号中的任意一个字符
echo "$text" | grep -E "[Hh]ello"

# [a-z] - 匹配范围内的字符
echo "$text" | grep -E "[a-z]+"
echo "$text" | grep -E "[A-Z]+"
echo "$text" | grep -E "[0-9]+"

# [^abc] - 匹配不在方括号中的字符
echo "$text" | grep -E "[^a-zA-Z0-9 ]+"

# 预定义字符类
echo "$text" | grep -E "\w+"     # 单词字符 [a-zA-Z0-9_]
echo "$text" | grep -E "\W+"     # 非单词字符
echo "$text" | grep -E "\d+"     # 数字字符 [0-9]
echo "$text" | grep -E "\D+"     # 非数字字符
echo "$text" | grep -E "\s+"     # 空白字符
echo "$text" | grep -E "\S+"     # 非空白字符

# POSIX字符类
echo "$text" | grep -E "[[:alpha:]]+"   # 字母
echo "$text" | grep -E "[[:digit:]]+"   # 数字
echo "$text" | grep -E "[[:alnum:]]+"   # 字母和数字
echo "$text" | grep -E "[[:space:]]+"   # 空白字符
echo "$text" | grep -E "[[:punct:]]+"   # 标点符号
```

### 量词
```bash
#!/bin/bash

# {n} - 精确匹配n次
echo "gooogle" | grep -E "o{4}"

# {n,} - 匹配n次或更多
echo "gooogle" | grep -E "o{2,}"

# {n,m} - 匹配n到m次
echo "gooogle" | grep -E "o{2,4}"

# 贪婪匹配 vs 非贪婪匹配
text="<tag>content</tag>"
echo "$text" | grep -oE "<.*>"      # 贪婪匹配：<tag>content</tag>
echo "$text" | grep -oE "<[^>]*>"   # 非贪婪匹配：<tag> 和 </tag>

# 实际应用示例
phone_numbers="138-1234-5678 139-5678-1234 150-9999-8888"

# 匹配手机号码
echo "$phone_numbers" | grep -oE "1[3-9][0-9]-[0-9]{4}-[0-9]{4}"

# 匹配邮箱地址
emails="user@example.com admin@test.org invalid.email"
echo "$emails" | grep -oE "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"
```

## 3. 分组和捕获

### 分组语法
```bash
#!/bin/bash

# () - 分组
text="2023-12-25 14:30:25"

# 使用bash内置正则匹配和BASH_REMATCH
if [[ $text =~ ^([0-9]{4})-([0-9]{2})-([0-9]{2})\ ([0-9]{2}):([0-9]{2}):([0-9]{2})$ ]]; then
    echo "完整匹配: ${BASH_REMATCH[0]}"
    echo "年份: ${BASH_REMATCH[1]}"
    echo "月份: ${BASH_REMATCH[2]}"
    echo "日期: ${BASH_REMATCH[3]}"
    echo "小时: ${BASH_REMATCH[4]}"
    echo "分钟: ${BASH_REMATCH[5]}"
    echo "秒钟: ${BASH_REMATCH[6]}"
fi

# | - 或操作符
echo "cat dog bird" | grep -E "(cat|dog)"

# (?:) - 非捕获分组（bash不支持，但sed/awk支持）
# 在sed中使用
echo "color colour" | sed -E 's/(colou?r)/[\1]/g'
```

### 实用分组示例
```bash
#!/bin/bash

# 解析URL
parse_url() {
    local url="$1"
    
    if [[ $url =~ ^(https?):\/\/([^\/]+)(\/.*)?$ ]]; then
        echo "协议: ${BASH_REMATCH[1]}"
        echo "主机: ${BASH_REMATCH[2]}"
        echo "路径: ${BASH_REMATCH[3]:-/}"
    else
        echo "无效的URL格式"
    fi
}

parse_url "https://www.example.com/path/to/page"
parse_url "http://localhost:8080"

# 解析日志条目
parse_log_entry() {
    local log_line="$1"
    
    # Apache访问日志格式
    local pattern='^([0-9.]+) - - \[([^\]+)\] "([A-Z]+) ([^"]+) HTTP/[^"]*" ([0-9]+) ([0-9]+|-)'
    
    if [[ $log_line =~ $pattern ]]; then
        echo "IP地址: ${BASH_REMATCH[1]}"
        echo "时间: ${BASH_REMATCH[2]}"
        echo "方法: ${BASH_REMATCH[3]}"
        echo "路径: ${BASH_REMATCH[4]}"
        echo "状态码: ${BASH_REMATCH[5]}"
        echo "响应大小: ${BASH_REMATCH[6]}"
    else
        echo "无法解析日志条目"
    fi
}

log_entry='192.168.1.1 - - [25/Dec/2023:14:30:25 +0800] "GET /index.html HTTP/1.1" 200 1234'
parse_log_entry "$log_entry"
```

## 4. 高级正则表达式

### 前瞻和后顾断言
```bash
#!/bin/bash

# 注意：bash的内置正则不支持前瞻后顾，需要使用grep -P或其他工具

# 正向前瞻 (?=pattern)
echo "password123" | grep -P "^(?=.*[a-z])(?=.*[A-Z])(?=.*\d).{8,}$"  # 密码强度检查

# 负向前瞻 (?!pattern)
echo "test123" | grep -P "^(?!.*password).*$"  # 不包含password

# 正向后顾 (?<=pattern)
echo "price: $100" | grep -oP "(?<=\$)\d+"  # 提取价格数字

# 负向后顾 (?<!pattern)
echo "100 $200" | grep -oP "(?<!\$)\d+"  # 不以$开头的数字

# 实用示例：提取HTML标签内容
extract_html_content() {
    local html="$1"
    local tag="$2"
    
    # 使用perl正则表达式
    echo "$html" | grep -oP "(?<=<$tag>).*?(?=</$tag>)"
}

html_content="<title>网页标题</title><p>段落内容</p>"
extract_html_content "$html_content" "title"
extract_html_content "$html_content" "p"
```

### 条件匹配
```bash
#!/bin/bash

# 使用sed进行条件替换
conditional_replace() {
    local text="$1"
    local condition="$2"
    local replacement="$3"
    
    # 只在满足条件的行进行替换
    echo "$text" | sed "/$condition/s/old/new/g"
}

# 使用awk进行条件匹配
conditional_match() {
    local file="$1"
    local condition="$2"
    local action="$3"
    
    awk "/$condition/ { $action }" "$file"
}

# 复杂条件示例
process_config_file() {
    local config_file="$1"
    
    # 处理配置文件：去除注释，处理变量替换
    sed -E '
        # 删除注释行
        /^[[:space:]]*#/d
        # 删除空行
        /^[[:space:]]*$/d
        # 处理变量替换
        s/\$\{([^}]+)\}/\${\1}/g
    ' "$config_file"
}
```

## 5. 实用正则表达式模式

### 常用验证模式
```bash
#!/bin/bash

# 邮箱验证
validate_email() {
    local email="$1"
    local pattern="^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"
    [[ $email =~ $pattern ]]
}

# 手机号验证
validate_phone() {
    local phone="$1"
    local pattern="^1[3-9][0-9]{9}$"
    [[ $phone =~ $pattern ]]
}

# IP地址验证
validate_ip() {
    local ip="$1"
    local pattern="^([0-9]{1,3}\.){3}[0-9]{1,3}$"
    
    if [[ $ip =~ $pattern ]]; then
        # 进一步验证每个八位组
        IFS='.' read -ra octets <<< "$ip"
        for octet in "${octets[@]}"; do
            if [[ $octet -gt 255 ]]; then
                return 1
            fi
        done
        return 0
    fi
    return 1
}

# URL验证
validate_url() {
    local url="$1"
    local pattern="^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)$"
    [[ $url =~ $pattern ]]
}

# 密码强度验证
validate_password() {
    local password="$1"
    
    # 至少8位，包含大小写字母、数字和特殊字符
    if [[ ${#password} -lt 8 ]]; then
        echo "密码长度至少8位"
        return 1
    fi
    
    if ! [[ $password =~ [a-z] ]]; then
        echo "密码必须包含小写字母"
        return 1
    fi
    
    if ! [[ $password =~ [A-Z] ]]; then
        echo "密码必须包含大写字母"
        return 1
    fi
    
    if ! [[ $password =~ [0-9] ]]; then
        echo "密码必须包含数字"
        return 1
    fi
    
    if ! [[ $password =~ [^a-zA-Z0-9] ]]; then
        echo "密码必须包含特殊字符"
        return 1
    fi
    
    return 0
}

# 身份证号验证
validate_id_card() {
    local id="$1"
    local pattern="^[0-9]{17}[0-9Xx]$"
    [[ $id =~ $pattern ]]
}

# 测试验证函数
test_validations() {
    echo "=== 正则表达式验证测试 ==="
    
    # 测试邮箱
    emails=("user@example.com" "invalid.email" "test@domain.co.uk" "user+tag@example.com")
    for email in "${emails[@]}"; do
        if validate_email "$email"; then
            echo "✓ 有效邮箱: $email"
        else
            echo "✗ 无效邮箱: $email"
        fi
    done
    
    echo
    
    # 测试手机号
    phones=("13812345678" "1381234567" "12812345678" "138123456789")
    for phone in "${phones[@]}"; do
        if validate_phone "$phone"; then
            echo "✓ 有效手机号: $phone"
        else
            echo "✗ 无效手机号: $phone"
        fi
    done
    
    echo
    
    # 测试IP地址
    ips=("192.168.1.1" "256.1.1.1" "10.0.0.1" "192.168.1")
    for ip in "${ips[@]}"; do
        if validate_ip "$ip"; then
            echo "✓ 有效IP: $ip"
        else
            echo "✗ 无效IP: $ip"
        fi
    done
}

# test_validations
```

### 数据提取模式
```bash
#!/bin/bash

# 提取HTML标签
extract_html_tags() {
    local html="$1"
    echo "$html" | grep -oE '<[^>]+>'
}

# 提取HTML标签内容
extract_html_content() {
    local html="$1"
    echo "$html" | sed -E 's/<[^>]*>//g'
}

# 提取URL
extract_urls() {
    local text="$1"
    echo "$text" | grep -oE 'https?://[^[:space:]]+'
}

# 提取邮箱地址
extract_emails() {
    local text="$1"
    echo "$text" | grep -oE '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}'
}

# 提取IP地址
extract_ips() {
    local text="$1"
    echo "$text" | grep -oE '([0-9]{1,3}\.){3}[0-9]{1,3}'
}

# 提取日期
extract_dates() {
    local text="$1"
    # 匹配 YYYY-MM-DD 格式
    echo "$text" | grep -oE '[0-9]{4}-[0-9]{2}-[0-9]{2}'
}

# 提取时间
extract_times() {
    local text="$1"
    # 匹配 HH:MM:SS 格式
    echo "$text" | grep -oE '[0-9]{2}:[0-9]{2}:[0-9]{2}'
}

# 提取数字
extract_numbers() {
    local text="$1"
    local type="${2:-integer}"
    
    case $type in
        integer)
            echo "$text" | grep -oE '[0-9]+'
            ;;
        float)
            echo "$text" | grep -oE '[0-9]+\.[0-9]+'
            ;;
        all)
            echo "$text" | grep -oE '[0-9]+\.?[0-9]*'
            ;;
    esac
}

# 测试提取功能
test_extraction() {
    local sample_text="访问 https://www.example.com 或发送邮件到 admin@example.com。
    服务器IP: 192.168.1.100，端口: 8080。
    日期: 2023-12-25，时间: 14:30:25。
    价格: $99.99，数量: 10个。"
    
    echo "原文本:"
    echo "$sample_text"
    echo
    
    echo "提取的URL:"
    extract_urls "$sample_text"
    echo
    
    echo "提取的邮箱:"
    extract_emails "$sample_text"
    echo
    
    echo "提取的IP地址:"
    extract_ips "$sample_text"
    echo
    
    echo "提取的日期:"
    extract_dates "$sample_text"
    echo
    
    echo "提取的时间:"
    extract_times "$sample_text"
    echo
    
    echo "提取的数字:"
    extract_numbers "$sample_text" "all"
}

# test_extraction
```

## 6. 正则表达式工具集成

### 使用grep进行高级搜索
```bash
#!/bin/bash

# 多模式搜索
multi_pattern_search() {
    local file="$1"
    shift
    local patterns=("$@")
    
    # 构建正则表达式
    local regex=""
    for pattern in "${patterns[@]}"; do
        if [[ -n $regex ]]; then
            regex+="|"
        fi
        regex+="($pattern)"
    done
    
    grep -E "$regex" "$file"
}

# 上下文搜索
context_search() {
    local file="$1"
    local pattern="$2"
    local before="${3:-2}"
    local after="${4:-2}"
    
    grep -B "$before" -A "$after" -E "$pattern" "$file"
}

# 递归搜索
recursive_search() {
    local directory="$1"
    local pattern="$2"
    local file_pattern="${3:-*}"
    
    find "$directory" -name "$file_pattern" -type f -exec grep -l -E "$pattern" {} \;
}

# 排除搜索
exclude_search() {
    local file="$1"
    local include_pattern="$2"
    local exclude_pattern="$3"
    
    grep -E "$include_pattern" "$file" | grep -v -E "$exclude_pattern"
}
```

### 使用sed进行高级替换
```bash
#!/bin/bash

# 条件替换
conditional_replace() {
    local file="$1"
    local condition="$2"
    local search="$3"
    local replace="$4"
    
    sed -E "/$condition/s/$search/$replace/g" "$file"
}

# 多行替换
multiline_replace() {
    local file="$1"
    local start_pattern="$2"
    local end_pattern="$3"
    local replacement="$4"
    
    sed -E "/$start_pattern/,/$end_pattern/c\\$replacement" "$file"
}

# 基于行号的替换
line_based_replace() {
    local file="$1"
    local start_line="$2"
    local end_line="$3"
    local search="$4"
    local replace="$5"
    
    sed -E "${start_line},${end_line}s/$search/$replace/g" "$file"
}

# 保留匹配组的替换
group_preserve_replace() {
    local file="$1"
    local pattern="$2"
    local replacement="$3"
    
    # 示例：将 "name: value" 转换为 "name = value"
    sed -E "s/^([^:]+):[[:space:]]*(.+)$/\1 = \2/" "$file"
}
```

### 使用awk进行模式处理
```bash
#!/bin/bash

# 基于正则的字段处理
regex_field_processing() {
    local file="$1"
    local pattern="$2"
    local field="$3"
    
    awk -v pat="$pattern" -v fld="$field" '$fld ~ pat { print $0 }' "$file"
}

# 复杂模式匹配和处理
complex_pattern_processing() {
    local file="$1"
    
    awk '
    # 匹配日志条目
    /^[0-9]{4}-[0-9]{2}-[0-9]{2}/ {
        # 提取日期
        match($0, /^[0-9]{4}-[0-9]{2}-[0-9]{2}/)
        date = substr($0, RSTART, RLENGTH)
        
        # 提取级别
        if (match($0, /\[(ERROR|WARN|INFO|DEBUG)\]/)) {
            level = substr($0, RSTART+1, RLENGTH-2)
        }
        
        # 提取消息
        if (match($0, /\] (.+)$/)) {
            message = substr($0, RSTART+2)
        }
        
        print date, level, message
    }' "$file"
}

# 统计模式匹配
pattern_statistics() {
    local file="$1"
    local pattern="$2"
    
    awk -v pat="$pattern" '
    $0 ~ pat { 
        count++
        lines[NR] = $0
    }
    END {
        print "匹配行数:", count
        print "匹配的行:"
        for (line_num in lines) {
            print line_num ":", lines[line_num]
        }
    }' "$file"
}
```

## 7. 实践练习

### 练习1：日志解析器
```bash
#!/bin/bash
# log_parser.sh - 高级日志解析器

# 解析Apache访问日志
parse_apache_log() {
    local log_file="$1"
    local output_format="${2:-json}"
    
    # Apache Common Log Format正则表达式
    local pattern='^([0-9.]+) ([^ ]+) ([^ ]+) \[([^\]]+)\] "([A-Z]+) ([^"]*) HTTP/[^"]*" ([0-9]+) ([0-9]+|-)(?: "([^"]*)" "([^"]*)")?'
    
    while IFS= read -r line; do
        if [[ $line =~ $pattern ]]; then
            local ip="${BASH_REMATCH[1]}"
            local identity="${BASH_REMATCH[2]}"
            local user="${BASH_REMATCH[3]}"
            local timestamp="${BASH_REMATCH[4]}"
            local method="${BASH_REMATCH[5]}"
            local url="${BASH_REMATCH[6]}"
            local status="${BASH_REMATCH[7]}"
            local size="${BASH_REMATCH[8]}"
            local referer="${BASH_REMATCH[9]}"
            local user_agent="${BASH_REMATCH[10]}"
            
            case $output_format in
                json)
                    cat << EOF
{
  "ip": "$ip",
  "timestamp": "$timestamp",
  "method": "$method",
  "url": "$url",
  "status": $status,
  "size": "${size:-0}",
  "referer": "$referer",
  "user_agent": "$user_agent"
}
EOF
                    ;;
                csv)
                    echo "$ip,$timestamp,$method,$url,$status,${size:-0},$referer,$user_agent"
                    ;;
                table)
                    printf "%-15s %-20s %-6s %-30s %-6s %-10s\n" "$ip" "$timestamp" "$method" "$url" "$status" "${size:-0}"
                    ;;
            esac
        fi
    done < "$log_file"
}

# 解析系统日志
parse_syslog() {
    local log_file="$1"
    local filter_level="${2:-.*}"
    
    # Syslog格式正则表达式
    local pattern='^([A-Za-z]{3} [0-9 ]{2} [0-9:]{8}) ([^ ]+) ([^:]+): (.+)$'
    
    while IFS= read -r line; do
        if [[ $line =~ $pattern ]]; then
            local timestamp="${BASH_REMATCH[1]}"
            local hostname="${BASH_REMATCH[2]}"
            local process="${BASH_REMATCH[3]}"
            local message="${BASH_REMATCH[4]}"
            
            # 提取日志级别
            local level="INFO"
            if [[ $message =~ (ERROR|WARN|INFO|DEBUG) ]]; then
                level="${BASH_REMATCH[1]}"
            fi
            
            # 过滤日志级别
            if [[ $level =~ $filter_level ]]; then
                echo "[$timestamp] [$hostname] [$process] [$level] $message"
            fi
        fi
    done < "$log_file"
}

# 解析应用日志
parse_application_log() {
    local log_file="$1"
    local app_name="$2"
    
    # 应用日志格式：YYYY-MM-DD HH:MM:SS [LEVEL] [MODULE] MESSAGE
    local pattern='^([0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}) \[([A-Z]+)\] \[([^\]]+)\] (.+)$'
    
    declare -A stats
    
    while IFS= read -r line; do
        if [[ $line =~ $pattern ]]; then
            local timestamp="${BASH_REMATCH[1]}"
            local level="${BASH_REMATCH[2]}"
            local module="${BASH_REMATCH[3]}"
            local message="${BASH_REMATCH[4]}"
            
            # 统计信息
            ((stats["total"]++))
            ((stats["level_$level"]++))
            ((stats["module_$module"]++))
            
            # 输出解析结果
            echo "时间: $timestamp | 级别: $level | 模块: $module | 消息: $message"
        fi
    done < "$log_file"
    
    # 输出统计信息
    echo
    echo "=== 统计信息 ==="
    echo "总日志条数: ${stats[total]}"
    
    echo "按级别统计:"
    for key in "${!stats[@]}"; do
        if [[ $key =~ ^level_ ]]; then
            local level="${key#level_}"
            echo "  $level: ${stats[$key]}"
        fi
    done
    
    echo "按模块统计:"
    for key in "${!stats[@]}"; do
        if [[ $key =~ ^module_ ]]; then
            local module="${key#module_}"
            echo "  $module: ${stats[$key]}"
        fi
    done
}

# 主函数
main() {
    local log_type="$1"
    local log_file="$2"
    local options="$3"
    
    if [[ ! -f "$log_file" ]]; then
        echo "错误: 日志文件不存在 - $log_file"
        exit 1
    fi
    
    case "$log_type" in
        apache)
            parse_apache_log "$log_file" "$options"
            ;;
        syslog)
            parse_syslog "$log_file" "$options"
            ;;
        app)
            parse_application_log "$log_file" "$options"
            ;;
        *)
            echo "用法: $0 <类型> <日志文件> [选项]"
            echo "类型:"
            echo "  apache  - Apache访问日志"
            echo "  syslog  - 系统日志"
            echo "  app     - 应用日志"
            exit 1
            ;;
    esac
}

main "$@"
```

### 练习2：数据验证器
```bash
#!/bin/bash
# data_validator.sh - 数据验证器

# 验证配置
declare -A validation_rules=(
    ["email"]="^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"
    ["phone"]="^1[3-9][0-9]{9}$"
    ["ip"]="^([0-9]{1,3}\.){3}[0-9]{1,3}$"
    ["url"]="^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)$"
    ["date"]="^[0-9]{4}-[0-9]{2}-[0-9]{2}$"
    ["time"]="^[0-9]{2}:[0-9]{2}:[0-9]{2}$"
    ["number"]="^-?[0-9]+$"
    ["float"]="^-?[0-9]+\.[0-9]+$"
    ["id_card"]="^[0-9]{17}[0-9Xx]$"
    ["postal_code"]="^[0-9]{6}$"
)

# 基本验证函数
validate_field() {
    local field_type="$1"
    local value="$2"
    local rule="${validation_rules[$field_type]}"
    
    if [[ -z "$rule" ]]; then
        echo "未知的字段类型: $field_type"
        return 1
    fi
    
    if [[ $value =~ $rule ]]; then
        return 0
    else
        return 1
    fi
}

# 高级验证函数
advanced_validate() {
    local field_type="$1"
    local value="$2"
    
    case "$field_type" in
        email)
            validate_field "email" "$value"
            ;;
        phone)
            validate_field "phone" "$value"
            ;;
        ip)
            validate_field "ip" "$value" && validate_ip_range "$value"
            ;;
        url)
            validate_field "url" "$value" && validate_url_accessibility "$value"
            ;;
        date)
            validate_field "date" "$value" && validate_date_range "$value"
            ;;
        password)
            validate_password_strength "$value"
            ;;
        *)
            validate_field "$field_type" "$value"
            ;;
    esac
}

# IP地址范围验证
validate_ip_range() {
    local ip="$1"
    IFS='.' read -ra octets <<< "$ip"
    
    for octet in "${octets[@]}"; do
        if [[ $octet -gt 255 ]]; then
            return 1
        fi
    done
    return 0
}

# URL可访问性验证
validate_url_accessibility() {
    local url="$1"
    local timeout="${2:-5}"
    
    if command -v curl >/dev/null; then
        curl -s --max-time "$timeout" --head "$url" >/dev/null
    else
        # 简单的连接测试
        return 0
    fi
}

# 日期范围验证
validate_date_range() {
    local date="$1"
    local min_date="${2:-1900-01-01}"
    local max_date="${3:-2100-12-31}"
    
    if [[ "$date" < "$min_date" ]] || [[ "$date" > "$max_date" ]]; then
        return 1
    fi
    return 0
}

# 密码强度验证
validate_password_strength() {
    local password="$1"
    local min_length="${2:-8}"
    local errors=()
    
    # 长度检查
    if [[ ${#password} -lt $min_length ]]; then
        errors+=("密码长度至少${min_length}位")
    fi
    
    # 字符类型检查
    if ! [[ $password =~ [a-z] ]]; then
        errors+=("必须包含小写字母")
    fi
    
    if ! [[ $password =~ [A-Z] ]]; then
        errors+=("必须包含大写字母")
    fi
    
    if ! [[ $password =~ [0-9] ]]; then
        errors+=("必须包含数字")
    fi
    
    if ! [[ $password =~ [^a-zA-Z0-9] ]]; then
        errors+=("必须包含特殊字符")
    fi
    
    # 常见密码检查
    local common_passwords=("password" "123456" "qwerty" "admin")
    for common in "${common_passwords[@]}"; do
        if [[ "${password,,}" == *"${common}"* ]]; then
            errors+=("不能包含常见密码模式")
            break
        fi
    done
    
    if [[ ${#errors[@]} -eq 0 ]]; then
        return 0
    else
        printf '%s\n' "${errors[@]}"
        return 1
    fi
}

# 批量验证
batch_validate() {
    local input_file="$1"
    local output_file="${2:-validation_results.txt}"
    local error_count=0
    local total_count=0
    
    {
        echo "数据验证报告"
        echo "输入文件: $input_file"
        echo "生成时间: $(date)"
        echo "========================================"
        echo
    } > "$output_file"
    
    while IFS=',' read -r field_type value; do
        ((total_count++))
        
        if advanced_validate "$field_type" "$value"; then
            echo "✓ $field_type: $value" >> "$output_file"
        else
            echo "✗ $field_type: $value" >> "$output_file"
            ((error_count++))
        fi
    done < "$input_file"
    
    {
        echo
        echo "========================================"
        echo "验证完成"
        echo "总计: $total_count 条记录"
        echo "通过: $((total_count - error_count)) 条"
        echo "失败: $error_count 条"
        echo "成功率: $(( (total_count - error_count) * 100 / total_count ))%"
    } >> "$output_file"
    
    echo "验证完成，结果保存在: $output_file"
}

# 交互式验证
interactive_validate() {
    echo "=== 交互式数据验证器 ==="
    echo "支持的数据类型: ${!validation_rules[*]}"
    echo "输入 'quit' 退出"
    echo
    
    while true; do
        read -p "请输入数据类型: " field_type
        
        if [[ "$field_type" == "quit" ]]; then
            break
        fi
        
        if [[ -z "${validation_rules[$field_type]}" ]]; then
            echo "不支持的数据类型: $field_type"
            continue
        fi
        
        read -p "请输入要验证的值: " value
        
        if advanced_validate "$field_type" "$value"; then
            echo "✓ 验证通过"
        else
            echo "✗ 验证失败"
        fi
        echo
    done
}

# 主函数
main() {
    case "${1:-interactive}" in
        validate)
            if [[ $# -lt 3 ]]; then
                echo "用法: $0 validate <类型> <值>"
                exit 1
            fi
            if advanced_validate "$2" "$3"; then
                echo "验证通过"
                exit 0
            else
                echo "验证失败"
                exit 1
            fi
            ;;
        batch)
            if [[ $# -lt 2 ]]; then
                echo "用法: $0 batch <输入文件> [输出文件]"
                exit 1
            fi
            batch_validate "$2" "$3"
            ;;
        interactive)
            interactive_validate
            ;;
        *)
            echo "用法: $0 [validate|batch|interactive] [参数...]"
            echo "  validate <类型> <值>     - 验证单个值"
            echo "  batch <输入文件>         - 批量验证"
            echo "  interactive              - 交互式验证"
            exit 1
            ;;
    esac
}

main "$@"
```

## 最佳实践

1. **性能考虑**：复杂正则表达式可能影响性能，适当优化
2. **可读性**：复杂正则表达式要添加注释说明
3. **测试验证**：充分测试正则表达式的边界情况
4. **工具选择**：根据需求选择合适的工具（grep、sed、awk等）
5. **转义处理**：注意特殊字符的转义
6. **编码问题**：处理多字节字符时要注意编码
7. **安全考虑**：避免正则表达式注入攻击